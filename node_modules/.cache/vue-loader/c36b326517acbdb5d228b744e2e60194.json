{"remainingRequest":"/mnt/websites/ex.nextsmartchain.com/node_modules/vue-loader/lib/index.js??vue-loader-options!/mnt/websites/ex.nextsmartchain.com/src/components/core/FLightweightCharts/FLightweightCharts.vue?vue&type=style&index=0&id=3cfd3e7d&prod&lang=scss&","dependencies":[{"path":"/mnt/websites/ex.nextsmartchain.com/src/components/core/FLightweightCharts/FLightweightCharts.vue","mtime":1657708592570},{"path":"/mnt/websites/ex.nextsmartchain.com/node_modules/css-loader/dist/cjs.js","mtime":1655491291170},{"path":"/mnt/websites/ex.nextsmartchain.com/node_modules/vue-loader/lib/loaders/stylePostLoader.js","mtime":1657708714280},{"path":"/mnt/websites/ex.nextsmartchain.com/node_modules/postcss-loader/src/index.js","mtime":1655491291810},{"path":"/mnt/websites/ex.nextsmartchain.com/node_modules/sass-loader/dist/cjs.js","mtime":1657625857833},{"path":"/mnt/websites/ex.nextsmartchain.com/node_modules/cache-loader/dist/cjs.js","mtime":1655491106804},{"path":"/mnt/websites/ex.nextsmartchain.com/node_modules/vue-loader/lib/index.js","mtime":1657708714280}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:CkBpbXBvcnQgJ3N0eWxlJzsK"},{"version":3,"sources":["FLightweightCharts.vue"],"names":[],"mappings":";AA4cA","file":"FLightweightCharts.vue","sourceRoot":"src/components/core/FLightweightCharts","sourcesContent":["<template>\n    <div class=\"f-lightweight-chart\">\n        <slot name=\"top\"></slot>\n        <div ref=\"chartContainer\" class=\"f-lightweight-chart__container\"></div>\n        <slot name=\"bottom\"></slot>\n    </div>\n</template>\n\n<script>\nimport { createChart } from 'lightweight-charts';\nimport { isArray, throttle } from '../../../utils';\n\nconst WEI = 1000000000000000000;\n\n/**\n * Lightweight chart series object.\n * @typedef {Object} LightweightSeries\n * @property {array} series Data for series.\n * @property {('line' | 'histogram' | 'area' | 'bar' | 'candlestick')} seriesType Type of series.\n * @property {('' | 'to-eth')} [transformValues]\n */\n\n/**\n * Lightweight charts wrapper.\n * https://www.tradingview.com/lightweight-charts/\n */\nexport default {\n    name: 'FLightweightCharts',\n\n    props: {\n        /**\n         * Data for chart.\n         * It can be series (array of series data) or object, where keys are unique series ids and values are objects\n         * of type LightweightSeries.\n         * @type {[] | {key: string, series: LightweightSeries}}\n         */\n        series: {\n            type: [Array, Object],\n            default() {\n                return [];\n            },\n        },\n        /**\n         * Type of series.\n         * @type {('line' | 'histogram' | 'area' | 'bar' | 'candlestick')}\n         */\n        seriesType: {\n            type: String,\n            default: 'line',\n            validator: function (_value) {\n                return ['line', 'histogram', 'area', 'bar', 'candlestick'].indexOf(_value) !== -1;\n            },\n        },\n        /** Lightweight chart's options. */\n        options: {\n            type: Object,\n            default() {\n                return {};\n            },\n        },\n        /** Lightweight chart's series options. */\n        seriesOptions: {\n            type: Object,\n            default() {\n                return {};\n            },\n        },\n        /** Chart height. */\n        height: {\n            type: Number,\n            default: 300,\n        },\n        /** Basic line color. */\n        color: {\n            type: String,\n            default: '#2040FF',\n        },\n        /** Default scale top margin */\n        scaleMarginTop: {\n            type: Number,\n            default: 0.1,\n        },\n        /** Default scale bottom margin */\n        scaleMarginBottom: {\n            type: Number,\n            default: 0.03,\n        },\n        /**\n         * @type {('' | 'to-eth')}\n         */\n        transformValues: {\n            type: String,\n            default: '',\n            validator: function (_value) {\n                return ['', 'to-eth'].indexOf(_value) !== -1;\n            },\n        },\n        /** Inject missing values */\n        addMissingValues: {\n            type: Object,\n            default() {\n                return {\n                    timeResolution: 0,\n                    value: 0,\n                };\n            },\n        },\n        /**\n         * Transform given series time to timestamp.\n         */\n        timeToTimestamp: {\n            type: Boolean,\n            default: false,\n        },\n        /**  */\n        fitContent: {\n            type: Boolean,\n            default: false,\n        },\n        /** Disable auto resizing. */\n        noAutoResize: {\n            type: Boolean,\n            default: false,\n        },\n    },\n\n    data() {\n        return {\n            dSeries: [],\n            chartOptions: {},\n        };\n    },\n\n    computed: {\n        cSeries() {\n            const { series } = this;\n            let data = {};\n\n            if (isArray(series)) {\n                data.series = {\n                    seriesType: this.seriesType,\n                    seriesOptions: this.seriesOptions,\n                    transformValues: this.transformValues,\n                    timeToTimestamp: this.timeToTimestamp,\n                    addMissingValues: this.addMissingValues,\n                    series: series,\n                };\n            }\n\n            if (!data.series) {\n                data = { ...series };\n            }\n\n            Object.keys(data).forEach((_seriesKey) => {\n                const item = data[_seriesKey];\n\n                if (item.timeToTimestamp || item.addMissingValues.timeResolution > 0) {\n                    this.transformTimeToTimestamp(item.series);\n                }\n\n                if (item.addMissingValues.timeResolution > 0) {\n                    item.series = this.injectMissingValues(item.series, item.addMissingValues);\n                }\n\n                if (item.transformValues) {\n                    if (item.transformValues === 'to-eth') {\n                        item.series = this.transformValuesToNEXT(item.series);\n                    }\n                }\n            });\n\n            return data;\n        },\n    },\n\n    watch: {\n        series() {\n            this.initChart();\n            // this.initSeries();\n        },\n    },\n\n    created() {\n        /** Lightweight chart instance. */\n        this._chart = null;\n        /** Array of Lightweight chart series instances. */\n        this._series = {};\n        /** Debounce function used as window resize callback. */\n        this._resizeCallback = throttle((_event) => this.onWindowResize(_event), 300, true);\n    },\n\n    mounted() {\n        // this.initChart();\n\n        if (!this.noAutoResize) {\n            window.addEventListener('resize', this._resizeCallback, false);\n        }\n    },\n\n    beforeDestroy() {\n        this.destroyChart();\n\n        if (!this.noAutoResize) {\n            window.removeEventListener('resize', this._resizeCallback);\n        }\n    },\n\n    methods: {\n        initChart() {\n            const defaultOptions = {\n                height: this.height,\n                priceScale: {},\n            };\n\n            this.destroyChart();\n\n            this.chartOptions = {\n                ...defaultOptions,\n                ...this.options,\n            };\n\n            if (!this.chartOptions.priceScale.scaleMargins) {\n                this.chartOptions.priceScale.scaleMargins = {\n                    top: this.scaleMarginTop,\n                    bottom: this.scaleMarginBottom,\n                };\n            }\n\n            this._chart = createChart(this.$refs.chartContainer, this.chartOptions);\n\n            this.initSeries();\n        },\n\n        initSeries() {\n            this._series = {};\n\n            Object.keys(this.cSeries).forEach((_seriesKey) => {\n                this.addSeries(_seriesKey);\n            });\n\n            this.updateColors();\n\n            if (this.fitContent) {\n                this._chart.timeScale().fitContent();\n            }\n        },\n\n        addSeries(_seriesKey) {\n            const chart = this._chart;\n            const seriesObj = this.cSeries[_seriesKey];\n\n            if (!chart || !seriesObj) {\n                return;\n            }\n\n            const defaultSeriesOptions = {\n                // color: this.color,\n            };\n            const seriesOptions = {\n                ...defaultSeriesOptions,\n                ...seriesObj.seriesOptions,\n            };\n            let series = null;\n\n            switch (seriesObj.seriesType) {\n                case 'line':\n                    series = chart.addLineSeries(seriesOptions);\n                    break;\n                case 'histogram':\n                    series = chart.addHistogramSeries(seriesOptions);\n                    break;\n                case 'area':\n                    series = chart.addAreaSeries(seriesOptions);\n                    break;\n                case 'bar':\n                    series = chart.addBarSeries(seriesOptions);\n                    break;\n                case 'candlestick':\n                    series = chart.addCandlestickSeries(seriesOptions);\n                    break;\n            }\n\n            if (series) {\n                series.setData(seriesObj.series);\n                this._series[_seriesKey] = series;\n            }\n        },\n\n        transformValuesToNEXT(_series) {\n            let data = [];\n            let item;\n\n            if (_series) {\n                for (let i = 0, len1 = _series.length; i < len1; i++) {\n                    item = _series[i];\n\n                    data.push({\n                        ...item,\n                        value: parseInt(item.value, 16) / WEI,\n                    });\n                }\n            }\n\n            return data;\n        },\n\n        transformTimeToTimestamp(_series) {\n            let date;\n\n            if (_series) {\n                for (let i = 0, len1 = _series.length; i < len1; i++) {\n                    date = new Date(_series[i].time);\n                    _series[i].time = Math.floor(date.getTime() / 1000);\n                }\n            }\n        },\n\n        injectMissingValues(_series, _options) {\n            let data = [];\n            let prevItem;\n            let item;\n            let diff = 0;\n            const { timeResolution } = _options;\n            const { value } = _options;\n            const useLastValue = value === 'last';\n\n            if (_series && timeResolution > 0) {\n                for (let i = 0, len1 = _series.length; i < len1; i++) {\n                    item = _series[i];\n\n                    if (i > 0) {\n                        prevItem = _series[i - 1];\n                        diff = item.time - prevItem.time;\n                        if (diff > timeResolution) {\n                            for (let j = 1, len2 = parseInt(diff / timeResolution); j < len2; j++) {\n                                data.push({\n                                    time: prevItem.time + j * timeResolution,\n                                    value: useLastValue ? prevItem.value : value,\n                                });\n                            }\n                        }\n                    }\n\n                    data.push({ ...item });\n                }\n            }\n\n            return data;\n        },\n\n        updateColors() {\n            const chartCP = this.getChartCustomProperties();\n            const series = this._series;\n            const { cSeries } = this;\n            const { chartOptions } = this;\n            const options = {\n                grid: {},\n                layout: {},\n                timeScale: {},\n                priceScale: {},\n            };\n            const grid = { ...chartOptions.grid };\n            const layout = { ...chartOptions.layout };\n            const timeScale = { ...chartOptions.timeScale };\n            const priceScale = { ...chartOptions.priceScale };\n\n            if (chartCP.vertLinesColor && (!grid.vertLines || !grid.vertLines.color)) {\n                options.grid.vertLines = { ...grid.vertLines, color: chartCP.vertLinesColor };\n            }\n\n            if (chartCP.horzLinesColor && (!grid.horzLines || !grid.horzLines.color)) {\n                options.grid.horzLines = { ...grid.horzLines, color: chartCP.horzLinesColor };\n            }\n\n            ['backgroundColor', 'textColor', 'fontSize', 'fontFamily'].forEach((_prop) => {\n                if (chartCP[_prop] && !layout[_prop]) {\n                    options.layout[_prop] = _prop === 'fontSize' ? parseInt(chartCP[_prop]) : chartCP[_prop];\n                }\n            });\n\n            if (chartCP.timeScaleBorderColor && !timeScale.borderColor) {\n                options.timeScale.borderColor = chartCP.timeScaleBorderColor;\n            }\n\n            if (chartCP.priceScaleBorderColor && !priceScale.borderColor) {\n                options.priceScale.borderColor = chartCP.priceScaleBorderColor;\n            }\n\n            this._chart.applyOptions(options);\n\n            Object.keys(series).forEach((_seriesKey) => {\n                const item = cSeries[_seriesKey];\n                const seriesOptions = { ...item.seriesOptions };\n\n                if (!item) {\n                    return;\n                }\n\n                if (chartCP.lineColor && (!seriesOptions || !seriesOptions.color)) {\n                    series[_seriesKey].applyOptions({\n                        color: chartCP.lineColor,\n                        lineColor: chartCP.lineColor,\n                        topColor: chartCP.topColor,\n                        bottomColor: chartCP.bottomColor,\n                        lineWidth: chartCP.lineWidth,\n                    });\n                }\n            });\n        },\n\n        getChartCustomProperties() {\n            const style = getComputedStyle(this.$el);\n            const cp = {\n                lineColor: style.getPropertyValue('--f-lightweight-chart-chart-line-color'),\n                textColor: style.getPropertyValue('--f-lightweight-chart-chart-text-color'),\n                topColor: style.getPropertyValue('--f-lightweight-chart-chart-top-color'),\n                bottomColor: style.getPropertyValue('--f-lightweight-chart-chart-bottom-color'),\n                lineWidth: style.getPropertyValue('--f-lightweight-chart-chart-line-width'),\n                vertLinesColor: style.getPropertyValue('--f-lightweight-chart-chart-vert-lines-color'),\n                horzLinesColor: style.getPropertyValue('--f-lightweight-chart-chart-horz-lines-color'),\n                backgroundColor: style.getPropertyValue('--f-lightweight-chart-chart-background-color'),\n                fontSize: style.getPropertyValue('--f-lightweight-chart-chart-font-size'),\n                fontFamily: style.getPropertyValue('--f-lightweight-chart-chart-font-family'),\n                timeScaleBorderColor: style.getPropertyValue('--f-lightweight-chart-chart-time-scale-border-color'),\n                priceScaleBorderColor: style.getPropertyValue('--f-lightweight-chart-chart-price-scale-border-color'),\n            };\n\n            Object.keys(cp).forEach((_key) => {\n                const color = cp[_key];\n\n                if (color) {\n                    cp[_key] = color.trim();\n                } else {\n                    delete cp[_key];\n                }\n            });\n\n            return cp;\n        },\n\n        destroyChart() {\n            if (this._chart) {\n                this._series = {};\n                this._chart.remove();\n                this._chart = null;\n            }\n        },\n\n        onWindowResize() {\n            const chart = this._chart;\n\n            if (chart) {\n                chart.resize(this.$refs.chartContainer.clientWidth, this.height);\n            }\n        },\n    },\n};\n</script>\n\n<style lang=\"scss\">\n@import 'style';\n</style>\n"]}]}