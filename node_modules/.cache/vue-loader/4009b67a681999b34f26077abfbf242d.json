{"remainingRequest":"/mnt/websites/ex.nextsmartchain.com/node_modules/vue-loader/lib/index.js??vue-loader-options!/mnt/websites/ex.nextsmartchain.com/src/components/core/FWindow/FWindow.vue?vue&type=style&index=0&id=94ac7e56&prod&lang=scss&","dependencies":[{"path":"/mnt/websites/ex.nextsmartchain.com/src/components/core/FWindow/FWindow.vue","mtime":1657708591926},{"path":"/mnt/websites/ex.nextsmartchain.com/node_modules/css-loader/dist/cjs.js","mtime":1655491291170},{"path":"/mnt/websites/ex.nextsmartchain.com/node_modules/vue-loader/lib/loaders/stylePostLoader.js","mtime":1657708714280},{"path":"/mnt/websites/ex.nextsmartchain.com/node_modules/postcss-loader/src/index.js","mtime":1655491291810},{"path":"/mnt/websites/ex.nextsmartchain.com/node_modules/sass-loader/dist/cjs.js","mtime":1657625857833},{"path":"/mnt/websites/ex.nextsmartchain.com/node_modules/cache-loader/dist/cjs.js","mtime":1655491106804},{"path":"/mnt/websites/ex.nextsmartchain.com/node_modules/vue-loader/lib/index.js","mtime":1657708714280}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:CkBpbXBvcnQgJ3N0eWxlJzsK"},{"version":3,"sources":["FWindow.vue"],"names":[],"mappings":";AA8qBA","file":"FWindow.vue","sourceRoot":"src/components/core/FWindow","sourcesContent":["<template>\n    <transition :enter-active-class=\"dAnimationIn\" :leave-active-class=\"dAnimationOut\">\n        <div\n            v-if=\"isVisible\"\n            :id=\"id\"\n            class=\"f-window\"\n            :class=\"cssClass\"\n            :style=\"style\"\n            :role=\"role\"\n            :aria-modal=\"modal\"\n            :aria-labelledby=\"_ids.title\"\n            :aria-describedby=\"_ids.body\"\n            @keyup=\"onKeyup\"\n            @keydown=\"onKeydown\"\n        >\n            <div ref=\"doc\" role=\"document\" tabindex=\"-1\" class=\"doc\">\n                <header v-if=\"withHeader\">\n                    <div :id=\"_ids.title\" class=\"title\">\n                        <!-- @slot Default to `title` prop -->\n                        <slot name=\"title\">\n                            <h2>{{ title }}</h2>\n                        </slot>\n                    </div>\n                    <div class=\"controls\" @click=\"onControlsClick\">\n                        <!-- @slot Default to `close-btn` button -->\n                        <slot name=\"controls\">\n                            <button class=\"btn close-btn same-size round light\" title=\"Close window\">\n                                <icon data=\"@/assets/svg/times.svg\" width=\"20\" height=\"20\" />\n                            </button>\n                        </slot>\n                    </div>\n                </header>\n\n                <div :id=\"_ids.body\" class=\"body\">\n                    <slot></slot>\n                </div>\n\n                <footer v-if=\"withFooter\">\n                    <slot name=\"footer\"></slot>\n                </footer>\n\n                <f-overlay\n                    v-if=\"dWithOverlay && isVisible\"\n                    ref=\"overlay\"\n                    :z-index=\"dZIndex - 1\"\n                    class=\"f-window-overlay\"\n                    :hide-on-click=\"hideOnEscapeKey\"\n                    @overlay-hide=\"onOverlayHide\"\n                />\n            </div>\n        </div>\n    </transition>\n</template>\n\n<script>\nimport { getLengthAndUnit, getComputedStyle } from '../../../utils/css.js';\nimport { getUniqueId, throttle } from '../../../utils/index.js';\nimport FOverlay from '../FOverlay/FOverlay.vue';\nimport { focusTrap, isKey, returnFocus, setReceiveFocusFromAttr } from '../../../utils/aria.js';\nimport ResizeObserver from 'resize-observer-polyfill';\nimport { helpersMixin } from '../../../mixins/helpers.js';\nimport {\n    attachElemTo,\n    getAlignment,\n    getAttachPosition,\n    getAttachPositionByRects,\n    getAutoAttachPosition,\n    getElemRect,\n} from '../../../utils/DOM.js';\n\n/**\n * Basic window following WAI-ARIA practices.\n * Needs `resize-observer-polyfill` plugin.\n */\nexport default {\n    name: 'FWindow',\n\n    components: { FOverlay },\n\n    mixins: [helpersMixin],\n\n    props: {\n        /** Is window visible on initialization? */\n        visible: {\n            type: Boolean,\n            default: false,\n        },\n        /** Title of window rendered in header. */\n        title: {\n            type: String,\n            default: '',\n        },\n        /** Has window a title? */\n        noTitle: {\n            type: Boolean,\n            default: false,\n        },\n        /** Animation that starts when the window is just about to show. */\n        animationIn: {\n            type: String,\n            default: 'fade-enter-active',\n        },\n        /** Animation that starts when the window is just about to hide. */\n        animationOut: {\n            type: String,\n            default: 'fade-leave-active',\n        },\n        /** WAI-ARIA role. */\n        role: {\n            type: String,\n            default: 'dialog',\n        },\n        /** Is window a modal? */\n        modal: {\n            type: Boolean,\n            default: false,\n        },\n        /** Is window a popover? */\n        popover: {\n            type: Boolean,\n            default: false,\n        },\n        /** `<header>` will be rendered. */\n        withHeader: {\n            type: Boolean,\n            default: true,\n        },\n        /** `<footer>` will be rendered. */\n        withFooter: {\n            type: Boolean,\n            default: false,\n        },\n        /** `FOverlay` shows. */\n        withOverlay: {\n            type: Boolean,\n            default: true,\n        },\n        /** 'fixed' | 'absolute' */\n        position: {\n            type: String,\n            default: 'fixed',\n        },\n        /** `z-index` of window, if overlay is used, it has `z-index` `zIndex -1`. */\n        zIndex: {\n            type: Number,\n            default: 10,\n        },\n        /** CSS selector. If window is popover, it will be attached to elemnet given by this selector. */\n        attachTo: {\n            type: String,\n            default: '',\n        },\n        /**\n         * How to place popover to `attachTo` element. (`'top'`, `'right'`, `'bottom'`, `'left'`, `'auto'`, `'[lcrm][tcbm] [lcrm][tcbm]'`)\n         *\n         * @type {('top', 'right', 'bottom', 'left', 'auto', '[lcrm][tcbm] [lcrm][tcbm]')}\n         */\n        attachPosition: {\n            type: String,\n            default: '',\n        },\n        /**\n         * Prefered attach position, if `attachPosition` is `'auto'`. (`'top'`, `'right'`, `'bottom'`, `'left'`, `'auto'`, `'[lcrm][tcbm] [lcrm][tcbm]'`)\n         *\n         * @type {('top', 'right', 'bottom', 'left', 'auto', '[lcrm][tcbm] [lcrm][tcbm]')}\n         */\n        preferredAttachPosition: {\n            type: String,\n            default: '',\n        },\n        /**\n         * Margin of popover. (`[top, right, bottom, left]`)\n         *\n         * @type {[number, number, number, number]}\n         */\n        attachMargin: {\n            type: Array,\n            default() {\n                return [0, 0, 0, 0];\n            },\n            validator: function (_value) {\n                return _value.length === 4;\n            },\n        },\n        /** Hide window after this amout of milliseconds. 0 means no auto hiding. */\n        hideAfter: {\n            type: Number,\n            default: 0,\n        },\n        /** Center window horizontally. */\n        centerHorizontally: {\n            type: Boolean,\n            default: true,\n        },\n        /** Center window vertically. */\n        centerVertically: {\n            type: Boolean,\n            default: true,\n        },\n        /** Make window stay in viewport. */\n        stayInViewport: {\n            type: Boolean,\n            default: true,\n        },\n        /** Hide window when browser window is resized. */\n        hideOnWindowResize: {\n            type: Boolean,\n            default: false,\n        },\n        /** Hide window on browser window mousedown. */\n        hideOnWindowMousedown: {\n            type: Boolean,\n            default: false,\n        },\n        /** Hide window when escape key is pressed. */\n        hideOnEscapeKey: {\n            type: Boolean,\n            default: true,\n        },\n    },\n\n    data() {\n        return {\n            id: getUniqueId(),\n            isVisible: false,\n            dPosition: this.popover ? 'absolute' : this.position,\n            dAnimationIn: this.animationIn,\n            dAnimationOut: this.animationOut,\n            dZIndex: this.zIndex,\n            dWithOverlay: this.popover ? false : this.withOverlay,\n            style: {\n                zIndex: this.zIndex,\n            },\n        };\n    },\n\n    computed: {\n        cssClass() {\n            return {\n                'pos-absolute': this.dPosition === 'absolute',\n                'pos-fixed': this.dPosition === 'fixed',\n                'with-header': this.withHeader,\n                'with-footer': this.withFooter,\n                'no-title': this.noTitle,\n                modal: this.modal,\n                popover: this.popover,\n            };\n        },\n    },\n\n    watch: {\n        visible(_value) {\n            this.isVisible = _value;\n        },\n    },\n\n    created() {\n        /** Initial css values of window. */\n        this._windowStyle = {\n            top: 0,\n            left: 0,\n            width: 0,\n            maxWidth: 0,\n            minWidth: 0,\n            height: 0,\n            maxHeight: 0,\n            minHeight: 0,\n            /*\n            borderTopLeftRadius: 0,\n            borderTopRightRadius: 0,\n            borderBottomLeftRadius: 0,\n            borderBottomRightRadius: 0,\n            */\n            _horHalfMarginSet: false, // helper\n            _verHalfMarginSet: false, // helper\n        };\n        /** Various ids. */\n        this._ids = {\n            comp: `fwin-${this._uid}`,\n            title: `fwin-title-${this._uid}`,\n            body: `fwin-body-${this._uid}`,\n        };\n        /** Debounce function used as window resize callback. */\n        this._resizeCallback = throttle((_event) => this.onWindowResize(_event), 300, true);\n        /** Instance of ResizeObserver. */\n        this._resizeObserver = null;\n        /** Stores first and last focusable elements in window. */\n        this._firstLastFocusables = {\n            first: null,\n            last: null,\n        };\n        /** `hideAfter` timeout id. */\n        this._hideAfterId = -1;\n    },\n\n    mounted() {\n        document.body.appendChild(this.$el);\n\n        if (this.hideOnWindowResize) {\n            window.addEventListener('resize', this._resizeCallback, false);\n        }\n\n        if (this.hideOnWindowMousedown) {\n            window.addEventListener('mousedown', this.onWindowMousedown, false);\n        }\n\n        if (this.visible) {\n            this.$nextTick(() => {\n                this.show();\n            });\n        }\n    },\n\n    beforeDestroy() {\n        this._firstLastFocusables = null;\n\n        if (this.hideOnWindowResize) {\n            window.removeEventListener('resize', this._resizeCallback);\n        }\n\n        if (this.hideOnWindowMousedown) {\n            window.removeEventListener('mousedown', this.onWindowMousedown);\n        }\n\n        this.clearHideAfterTimeout();\n\n        this.destroyResizeObserver();\n    },\n\n    destroyed() {\n        this.$el.remove();\n    },\n\n    methods: {\n        show(_animationIn) {\n            if (!this.isVisible) {\n                const parentWindow = this.findParentByName('f-window');\n\n                if (parentWindow) {\n                    this.dZIndex = parentWindow.dZIndex + 2;\n                    this._updateStyle({ zIndex: this.dZIndex });\n                }\n\n                if (_animationIn) {\n                    this.dAnimationIn = _animationIn;\n                } else {\n                    this.dAnimationIn = this.animationIn;\n                }\n\n                setReceiveFocusFromAttr(this._ids.comp);\n\n                this._firstLastFocusables.first = null;\n                this._firstLastFocusables.last = null;\n\n                this.isVisible = true;\n\n                this.$nextTick(() => {\n                    getComputedStyle(this.$el, this._windowStyle);\n                    this.setPosition();\n                    // this.focus();\n                    this.createResizeObserver();\n                });\n\n                this.startHideAfterTimeout();\n            }\n        },\n\n        hide(_animationOut, _byOverlay) {\n            if (this.isVisible) {\n                if (!_byOverlay) {\n                    if (_animationOut) {\n                        this.dAnimationOut = _animationOut;\n                    } else {\n                        this.dAnimationOut = this.animationOut;\n                    }\n                }\n\n                if (this.dWithOverlay && !_byOverlay) {\n                    this.$refs.overlay.hide();\n                } else {\n                    this.destroyResizeObserver();\n                    this.isVisible = false;\n\n                    this.$emit('window-hide');\n                }\n\n                returnFocus(this._ids.comp);\n            }\n        },\n\n        toggle() {\n            if (!this.isVisible) {\n                this.show();\n            } else {\n                this.hide();\n            }\n        },\n\n        /**\n         * Focus element with `data-focus` attribute or focus `.doc` by default.\n         */\n        focus() {\n            const focusElem = this.$el.querySelector('[data-focus]');\n            let inputElem = null;\n\n            if (focusElem) {\n                // try to find element with `name` attribute\n                inputElem = focusElem.querySelector('[name]');\n                if (inputElem) {\n                    inputElem.focus();\n                } else {\n                    focusElem.focus();\n                }\n            } else {\n                this.$nextTick(() => {\n                    this.$refs.doc.focus();\n                });\n            }\n        },\n\n        setPosition() {\n            const style = {};\n\n            if (this.isVisible) {\n                if (this.dPosition === 'fixed') {\n                    if (this.centerHorizontally) {\n                        this._setHalfMargin(style);\n                        style.left = '50%';\n                    }\n\n                    if (this.centerVertically) {\n                        this._setHalfMargin(style, true);\n                        style.top = '50%';\n                    }\n                }\n\n                this._updateStyle(style);\n\n                this.$nextTick(() => {\n                    this.correctPositionAndSize();\n                });\n\n                // defer(() => this.correctPositionAndSize());\n            }\n        },\n\n        correctPositionAndSize() {\n            let rect;\n            // let attachMargin;\n            // let pos;\n            const css = {};\n            const windowStyle = this._windowStyle;\n\n            if (!this.isVisible) {\n                return;\n            }\n\n            if (this.dPosition === 'fixed') {\n                rect = this.$el.getBoundingClientRect();\n\n                if (this.centerHorizontally) {\n                    if (windowStyle._horHalfMarginSet && rect.left < 0) {\n                        css.marginLeft = 0;\n                        css.left = 0;\n\n                        windowStyle._horHalfMarginSet = false;\n                    } else if (!windowStyle._horHalfMarginSet && rect.width < document.documentElement.clientWidth) {\n                        this._setHalfMargin(css);\n                        css.left = '50%';\n                    }\n                }\n\n                if (this.centerVertically) {\n                    if (windowStyle._verHalfMarginSet && rect.top <= 0) {\n                        css.marginTop = 0;\n                        css.top = 0;\n\n                        windowStyle._verHalfMarginSet = false;\n                    } else if (!windowStyle._verHalfMarginSet && rect.height < document.documentElement.clientHeight) {\n                        this._setHalfMargin(css, true);\n                        css.top = '50%';\n                    }\n\n                    if (rect.top > 0) {\n                        this._setHalfMargin(css, true);\n                    }\n                }\n\n                this._updateStyle(css);\n            } else if (this.dPosition === 'absolute') {\n                if (this.attachTo || this.attachToPoint) {\n                    const attachMargin = this.attachMargin;\n\n                    rect = attachElemTo(\n                        this.$el,\n                        this.attachToPoint || document.querySelector(this.attachTo),\n                        this._getAlignment(),\n                        this.stayInViewport,\n                        {\n                            top: attachMargin[0],\n                            right: attachMargin[1],\n                            bottom: attachMargin[2],\n                            left: attachMargin[3],\n                        }\n                    );\n\n                    this.attachToPoint = null;\n                }\n            }\n        },\n\n        createResizeObserver() {\n            if (!this._resizeObserver) {\n                this._resizeObserver = new ResizeObserver(throttle((_entries) => this.onResize(_entries), 300, true));\n                this._resizeObserver.observe(this.$el);\n            }\n        },\n\n        destroyResizeObserver() {\n            if (this._resizeObserver) {\n                this._resizeObserver.disconnect();\n                this._resizeObserver = null;\n            }\n        },\n\n        startHideAfterTimeout() {\n            if (this.hideAfter > 0) {\n                this.clearHideAfterTimeout();\n\n                this._hideAfterId = setTimeout(() => {\n                    this.hide();\n                }, this.hideAfter);\n            }\n        },\n\n        clearHideAfterTimeout() {\n            if (this._hideAfterId > -1) {\n                clearTimeout(this._hideAfterId);\n            }\n        },\n\n        _setHalfMargin(_style, _setTopMargin) {\n            const margin = this._getHalfMargin(_setTopMargin);\n            const windowStyle = this._windowStyle;\n            let style;\n\n            if (margin) {\n                style = _style || this.$el.style;\n\n                if (_setTopMargin) {\n                    style.marginTop = margin;\n                    windowStyle._verHalfMarginSet = true;\n                } else {\n                    style.marginLeft = margin;\n                    windowStyle._horHalfMarginSet = true;\n                }\n            }\n        },\n\n        _getHalfMargin(_getTopMargin) {\n            const windowStyle = this._windowStyle;\n            const { clientHeight } = this.$el;\n\n            if (windowStyle.height === 'auto') {\n                windowStyle.height = `${clientHeight}px`;\n            }\n\n            const lau = getLengthAndUnit(\n                // eslint-disable-next-line no-nested-ternary\n                _getTopMargin\n                    ? parseInt(windowStyle.height, 10)\n                        ? `${clientHeight}px`\n                        : windowStyle.maxHeight\n                    : parseInt(windowStyle.maxWidth, 10)\n                    ? windowStyle.maxWidth\n                    : windowStyle.width\n            );\n\n            if (lau.len) {\n                return -(lau.len / 2) + lau.unit;\n            }\n            return '';\n        },\n\n        _updateStyle(_css) {\n            this.style = {\n                ...this.style,\n                ..._css,\n            };\n        },\n\n        _getAlignment() {\n            let alignment = ['lt', 'lb'];\n            let { attachPosition } = this;\n            let pos;\n\n            if (attachPosition) {\n                if (attachPosition.indexOf('auto') > -1) {\n                    if (this.attachToPoint) {\n                        pos = getAttachPositionByRects(getElemRect(this.$el), {\n                            width: 1,\n                            height: 1,\n                            left: this.attachToPoint[0],\n                            top: this.attachToPoint[1],\n                        });\n                    } else if (this.attachTo) {\n                        pos = getAttachPosition(this.$el, document.querySelector(this.attachTo));\n                    }\n\n                    attachPosition = getAutoAttachPosition(pos, attachPosition, this.preferredAttachPosition);\n                }\n\n                alignment = getAlignment(attachPosition);\n            }\n\n            return alignment;\n        },\n\n        /**\n         * @return {boolean}\n         */\n        isChildWindowOpened() {\n            const openedWindow = this.findChildByName('f-window', false, (_component) => _component.isVisible);\n\n            return !!openedWindow;\n        },\n\n        onWindowResize() {\n            if (this.isVisible) {\n                if (this.hideOnWindowResize) {\n                    this.hide();\n                } /* else {\n                    this.correctPositionAndSize();\n                }*/\n            }\n        },\n\n        /**\n         * @param {MouseEvent} _event\n         */\n        onWindowMousedown(_event) {\n            if (\n                this.isVisible &&\n                this.hideOnWindowMousedown &&\n                !_event.target.closest(`#${this.id}`) &&\n                !this.isChildWindowOpened()\n            ) {\n                this.hide();\n            }\n        },\n\n        /**\n         * Called by ResizeObserver when FWindow is resized.\n         */\n        onResize() {\n            if (this.isVisible) {\n                this.correctPositionAndSize();\n            }\n        },\n\n        onOverlayHide(_hiddenByClick) {\n            this.hide('', true, _hiddenByClick);\n        },\n\n        onControlsClick(_event) {\n            if (_event.target.closest('.close-btn')) {\n                this.hide();\n            }\n        },\n\n        onKeyup(_event) {\n            if (this.hideOnEscapeKey) {\n                if (isKey('Escape', _event)) {\n                    this.hide();\n                }\n            }\n        },\n\n        onKeydown(_event) {\n            focusTrap(_event, this.$el, this._firstLastFocusables);\n        },\n    },\n};\n</script>\n\n<style lang=\"scss\">\n@import 'style';\n</style>\n"]}]}