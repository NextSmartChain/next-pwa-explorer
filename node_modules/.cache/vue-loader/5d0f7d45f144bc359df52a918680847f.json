{"remainingRequest":"/mnt/websites/ex.nextsmartchain.com/node_modules/vue-loader/lib/index.js??vue-loader-options!/mnt/websites/ex.nextsmartchain.com/src/components/core/FLightweightCharts/FLightweightCharts.vue?vue&type=script&lang=js&","dependencies":[{"path":"/mnt/websites/ex.nextsmartchain.com/src/components/core/FLightweightCharts/FLightweightCharts.vue","mtime":1657708592570},{"path":"/mnt/websites/ex.nextsmartchain.com/node_modules/babel-loader/lib/index.js","mtime":1655491285588},{"path":"/mnt/websites/ex.nextsmartchain.com/node_modules/cache-loader/dist/cjs.js","mtime":1655491106804},{"path":"/mnt/websites/ex.nextsmartchain.com/node_modules/vue-loader/lib/index.js","mtime":1657708714280}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:CmltcG9ydCB7IGNyZWF0ZUNoYXJ0IH0gZnJvbSAnbGlnaHR3ZWlnaHQtY2hhcnRzJzsKaW1wb3J0IHsgaXNBcnJheSwgdGhyb3R0bGUgfSBmcm9tICcuLi8uLi8uLi91dGlscyc7Cgpjb25zdCBXRUkgPSAxMDAwMDAwMDAwMDAwMDAwMDAwOwoKLyoqCiAqIExpZ2h0d2VpZ2h0IGNoYXJ0IHNlcmllcyBvYmplY3QuCiAqIEB0eXBlZGVmIHtPYmplY3R9IExpZ2h0d2VpZ2h0U2VyaWVzCiAqIEBwcm9wZXJ0eSB7YXJyYXl9IHNlcmllcyBEYXRhIGZvciBzZXJpZXMuCiAqIEBwcm9wZXJ0eSB7KCdsaW5lJyB8ICdoaXN0b2dyYW0nIHwgJ2FyZWEnIHwgJ2JhcicgfCAnY2FuZGxlc3RpY2snKX0gc2VyaWVzVHlwZSBUeXBlIG9mIHNlcmllcy4KICogQHByb3BlcnR5IHsoJycgfCAndG8tZXRoJyl9IFt0cmFuc2Zvcm1WYWx1ZXNdCiAqLwoKLyoqCiAqIExpZ2h0d2VpZ2h0IGNoYXJ0cyB3cmFwcGVyLgogKiBodHRwczovL3d3dy50cmFkaW5ndmlldy5jb20vbGlnaHR3ZWlnaHQtY2hhcnRzLwogKi8KZXhwb3J0IGRlZmF1bHQgewogICAgbmFtZTogJ0ZMaWdodHdlaWdodENoYXJ0cycsCgogICAgcHJvcHM6IHsKICAgICAgICAvKioKICAgICAgICAgKiBEYXRhIGZvciBjaGFydC4KICAgICAgICAgKiBJdCBjYW4gYmUgc2VyaWVzIChhcnJheSBvZiBzZXJpZXMgZGF0YSkgb3Igb2JqZWN0LCB3aGVyZSBrZXlzIGFyZSB1bmlxdWUgc2VyaWVzIGlkcyBhbmQgdmFsdWVzIGFyZSBvYmplY3RzCiAgICAgICAgICogb2YgdHlwZSBMaWdodHdlaWdodFNlcmllcy4KICAgICAgICAgKiBAdHlwZSB7W10gfCB7a2V5OiBzdHJpbmcsIHNlcmllczogTGlnaHR3ZWlnaHRTZXJpZXN9fQogICAgICAgICAqLwogICAgICAgIHNlcmllczogewogICAgICAgICAgICB0eXBlOiBbQXJyYXksIE9iamVjdF0sCiAgICAgICAgICAgIGRlZmF1bHQoKSB7CiAgICAgICAgICAgICAgICByZXR1cm4gW107CiAgICAgICAgICAgIH0sCiAgICAgICAgfSwKICAgICAgICAvKioKICAgICAgICAgKiBUeXBlIG9mIHNlcmllcy4KICAgICAgICAgKiBAdHlwZSB7KCdsaW5lJyB8ICdoaXN0b2dyYW0nIHwgJ2FyZWEnIHwgJ2JhcicgfCAnY2FuZGxlc3RpY2snKX0KICAgICAgICAgKi8KICAgICAgICBzZXJpZXNUeXBlOiB7CiAgICAgICAgICAgIHR5cGU6IFN0cmluZywKICAgICAgICAgICAgZGVmYXVsdDogJ2xpbmUnLAogICAgICAgICAgICB2YWxpZGF0b3I6IGZ1bmN0aW9uIChfdmFsdWUpIHsKICAgICAgICAgICAgICAgIHJldHVybiBbJ2xpbmUnLCAnaGlzdG9ncmFtJywgJ2FyZWEnLCAnYmFyJywgJ2NhbmRsZXN0aWNrJ10uaW5kZXhPZihfdmFsdWUpICE9PSAtMTsKICAgICAgICAgICAgfSwKICAgICAgICB9LAogICAgICAgIC8qKiBMaWdodHdlaWdodCBjaGFydCdzIG9wdGlvbnMuICovCiAgICAgICAgb3B0aW9uczogewogICAgICAgICAgICB0eXBlOiBPYmplY3QsCiAgICAgICAgICAgIGRlZmF1bHQoKSB7CiAgICAgICAgICAgICAgICByZXR1cm4ge307CiAgICAgICAgICAgIH0sCiAgICAgICAgfSwKICAgICAgICAvKiogTGlnaHR3ZWlnaHQgY2hhcnQncyBzZXJpZXMgb3B0aW9ucy4gKi8KICAgICAgICBzZXJpZXNPcHRpb25zOiB7CiAgICAgICAgICAgIHR5cGU6IE9iamVjdCwKICAgICAgICAgICAgZGVmYXVsdCgpIHsKICAgICAgICAgICAgICAgIHJldHVybiB7fTsKICAgICAgICAgICAgfSwKICAgICAgICB9LAogICAgICAgIC8qKiBDaGFydCBoZWlnaHQuICovCiAgICAgICAgaGVpZ2h0OiB7CiAgICAgICAgICAgIHR5cGU6IE51bWJlciwKICAgICAgICAgICAgZGVmYXVsdDogMzAwLAogICAgICAgIH0sCiAgICAgICAgLyoqIEJhc2ljIGxpbmUgY29sb3IuICovCiAgICAgICAgY29sb3I6IHsKICAgICAgICAgICAgdHlwZTogU3RyaW5nLAogICAgICAgICAgICBkZWZhdWx0OiAnIzIwNDBGRicsCiAgICAgICAgfSwKICAgICAgICAvKiogRGVmYXVsdCBzY2FsZSB0b3AgbWFyZ2luICovCiAgICAgICAgc2NhbGVNYXJnaW5Ub3A6IHsKICAgICAgICAgICAgdHlwZTogTnVtYmVyLAogICAgICAgICAgICBkZWZhdWx0OiAwLjEsCiAgICAgICAgfSwKICAgICAgICAvKiogRGVmYXVsdCBzY2FsZSBib3R0b20gbWFyZ2luICovCiAgICAgICAgc2NhbGVNYXJnaW5Cb3R0b206IHsKICAgICAgICAgICAgdHlwZTogTnVtYmVyLAogICAgICAgICAgICBkZWZhdWx0OiAwLjAzLAogICAgICAgIH0sCiAgICAgICAgLyoqCiAgICAgICAgICogQHR5cGUgeygnJyB8ICd0by1ldGgnKX0KICAgICAgICAgKi8KICAgICAgICB0cmFuc2Zvcm1WYWx1ZXM6IHsKICAgICAgICAgICAgdHlwZTogU3RyaW5nLAogICAgICAgICAgICBkZWZhdWx0OiAnJywKICAgICAgICAgICAgdmFsaWRhdG9yOiBmdW5jdGlvbiAoX3ZhbHVlKSB7CiAgICAgICAgICAgICAgICByZXR1cm4gWycnLCAndG8tZXRoJ10uaW5kZXhPZihfdmFsdWUpICE9PSAtMTsKICAgICAgICAgICAgfSwKICAgICAgICB9LAogICAgICAgIC8qKiBJbmplY3QgbWlzc2luZyB2YWx1ZXMgKi8KICAgICAgICBhZGRNaXNzaW5nVmFsdWVzOiB7CiAgICAgICAgICAgIHR5cGU6IE9iamVjdCwKICAgICAgICAgICAgZGVmYXVsdCgpIHsKICAgICAgICAgICAgICAgIHJldHVybiB7CiAgICAgICAgICAgICAgICAgICAgdGltZVJlc29sdXRpb246IDAsCiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IDAsCiAgICAgICAgICAgICAgICB9OwogICAgICAgICAgICB9LAogICAgICAgIH0sCiAgICAgICAgLyoqCiAgICAgICAgICogVHJhbnNmb3JtIGdpdmVuIHNlcmllcyB0aW1lIHRvIHRpbWVzdGFtcC4KICAgICAgICAgKi8KICAgICAgICB0aW1lVG9UaW1lc3RhbXA6IHsKICAgICAgICAgICAgdHlwZTogQm9vbGVhbiwKICAgICAgICAgICAgZGVmYXVsdDogZmFsc2UsCiAgICAgICAgfSwKICAgICAgICAvKiogICovCiAgICAgICAgZml0Q29udGVudDogewogICAgICAgICAgICB0eXBlOiBCb29sZWFuLAogICAgICAgICAgICBkZWZhdWx0OiBmYWxzZSwKICAgICAgICB9LAogICAgICAgIC8qKiBEaXNhYmxlIGF1dG8gcmVzaXppbmcuICovCiAgICAgICAgbm9BdXRvUmVzaXplOiB7CiAgICAgICAgICAgIHR5cGU6IEJvb2xlYW4sCiAgICAgICAgICAgIGRlZmF1bHQ6IGZhbHNlLAogICAgICAgIH0sCiAgICB9LAoKICAgIGRhdGEoKSB7CiAgICAgICAgcmV0dXJuIHsKICAgICAgICAgICAgZFNlcmllczogW10sCiAgICAgICAgICAgIGNoYXJ0T3B0aW9uczoge30sCiAgICAgICAgfTsKICAgIH0sCgogICAgY29tcHV0ZWQ6IHsKICAgICAgICBjU2VyaWVzKCkgewogICAgICAgICAgICBjb25zdCB7IHNlcmllcyB9ID0gdGhpczsKICAgICAgICAgICAgbGV0IGRhdGEgPSB7fTsKCiAgICAgICAgICAgIGlmIChpc0FycmF5KHNlcmllcykpIHsKICAgICAgICAgICAgICAgIGRhdGEuc2VyaWVzID0gewogICAgICAgICAgICAgICAgICAgIHNlcmllc1R5cGU6IHRoaXMuc2VyaWVzVHlwZSwKICAgICAgICAgICAgICAgICAgICBzZXJpZXNPcHRpb25zOiB0aGlzLnNlcmllc09wdGlvbnMsCiAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtVmFsdWVzOiB0aGlzLnRyYW5zZm9ybVZhbHVlcywKICAgICAgICAgICAgICAgICAgICB0aW1lVG9UaW1lc3RhbXA6IHRoaXMudGltZVRvVGltZXN0YW1wLAogICAgICAgICAgICAgICAgICAgIGFkZE1pc3NpbmdWYWx1ZXM6IHRoaXMuYWRkTWlzc2luZ1ZhbHVlcywKICAgICAgICAgICAgICAgICAgICBzZXJpZXM6IHNlcmllcywKICAgICAgICAgICAgICAgIH07CiAgICAgICAgICAgIH0KCiAgICAgICAgICAgIGlmICghZGF0YS5zZXJpZXMpIHsKICAgICAgICAgICAgICAgIGRhdGEgPSB7IC4uLnNlcmllcyB9OwogICAgICAgICAgICB9CgogICAgICAgICAgICBPYmplY3Qua2V5cyhkYXRhKS5mb3JFYWNoKChfc2VyaWVzS2V5KSA9PiB7CiAgICAgICAgICAgICAgICBjb25zdCBpdGVtID0gZGF0YVtfc2VyaWVzS2V5XTsKCiAgICAgICAgICAgICAgICBpZiAoaXRlbS50aW1lVG9UaW1lc3RhbXAgfHwgaXRlbS5hZGRNaXNzaW5nVmFsdWVzLnRpbWVSZXNvbHV0aW9uID4gMCkgewogICAgICAgICAgICAgICAgICAgIHRoaXMudHJhbnNmb3JtVGltZVRvVGltZXN0YW1wKGl0ZW0uc2VyaWVzKTsKICAgICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgICBpZiAoaXRlbS5hZGRNaXNzaW5nVmFsdWVzLnRpbWVSZXNvbHV0aW9uID4gMCkgewogICAgICAgICAgICAgICAgICAgIGl0ZW0uc2VyaWVzID0gdGhpcy5pbmplY3RNaXNzaW5nVmFsdWVzKGl0ZW0uc2VyaWVzLCBpdGVtLmFkZE1pc3NpbmdWYWx1ZXMpOwogICAgICAgICAgICAgICAgfQoKICAgICAgICAgICAgICAgIGlmIChpdGVtLnRyYW5zZm9ybVZhbHVlcykgewogICAgICAgICAgICAgICAgICAgIGlmIChpdGVtLnRyYW5zZm9ybVZhbHVlcyA9PT0gJ3RvLWV0aCcpIHsKICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS5zZXJpZXMgPSB0aGlzLnRyYW5zZm9ybVZhbHVlc1RvTkVYVChpdGVtLnNlcmllcyk7CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgfQogICAgICAgICAgICB9KTsKCiAgICAgICAgICAgIHJldHVybiBkYXRhOwogICAgICAgIH0sCiAgICB9LAoKICAgIHdhdGNoOiB7CiAgICAgICAgc2VyaWVzKCkgewogICAgICAgICAgICB0aGlzLmluaXRDaGFydCgpOwogICAgICAgICAgICAvLyB0aGlzLmluaXRTZXJpZXMoKTsKICAgICAgICB9LAogICAgfSwKCiAgICBjcmVhdGVkKCkgewogICAgICAgIC8qKiBMaWdodHdlaWdodCBjaGFydCBpbnN0YW5jZS4gKi8KICAgICAgICB0aGlzLl9jaGFydCA9IG51bGw7CiAgICAgICAgLyoqIEFycmF5IG9mIExpZ2h0d2VpZ2h0IGNoYXJ0IHNlcmllcyBpbnN0YW5jZXMuICovCiAgICAgICAgdGhpcy5fc2VyaWVzID0ge307CiAgICAgICAgLyoqIERlYm91bmNlIGZ1bmN0aW9uIHVzZWQgYXMgd2luZG93IHJlc2l6ZSBjYWxsYmFjay4gKi8KICAgICAgICB0aGlzLl9yZXNpemVDYWxsYmFjayA9IHRocm90dGxlKChfZXZlbnQpID0+IHRoaXMub25XaW5kb3dSZXNpemUoX2V2ZW50KSwgMzAwLCB0cnVlKTsKICAgIH0sCgogICAgbW91bnRlZCgpIHsKICAgICAgICAvLyB0aGlzLmluaXRDaGFydCgpOwoKICAgICAgICBpZiAoIXRoaXMubm9BdXRvUmVzaXplKSB7CiAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCB0aGlzLl9yZXNpemVDYWxsYmFjaywgZmFsc2UpOwogICAgICAgIH0KICAgIH0sCgogICAgYmVmb3JlRGVzdHJveSgpIHsKICAgICAgICB0aGlzLmRlc3Ryb3lDaGFydCgpOwoKICAgICAgICBpZiAoIXRoaXMubm9BdXRvUmVzaXplKSB7CiAgICAgICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCB0aGlzLl9yZXNpemVDYWxsYmFjayk7CiAgICAgICAgfQogICAgfSwKCiAgICBtZXRob2RzOiB7CiAgICAgICAgaW5pdENoYXJ0KCkgewogICAgICAgICAgICBjb25zdCBkZWZhdWx0T3B0aW9ucyA9IHsKICAgICAgICAgICAgICAgIGhlaWdodDogdGhpcy5oZWlnaHQsCiAgICAgICAgICAgICAgICBwcmljZVNjYWxlOiB7fSwKICAgICAgICAgICAgfTsKCiAgICAgICAgICAgIHRoaXMuZGVzdHJveUNoYXJ0KCk7CgogICAgICAgICAgICB0aGlzLmNoYXJ0T3B0aW9ucyA9IHsKICAgICAgICAgICAgICAgIC4uLmRlZmF1bHRPcHRpb25zLAogICAgICAgICAgICAgICAgLi4udGhpcy5vcHRpb25zLAogICAgICAgICAgICB9OwoKICAgICAgICAgICAgaWYgKCF0aGlzLmNoYXJ0T3B0aW9ucy5wcmljZVNjYWxlLnNjYWxlTWFyZ2lucykgewogICAgICAgICAgICAgICAgdGhpcy5jaGFydE9wdGlvbnMucHJpY2VTY2FsZS5zY2FsZU1hcmdpbnMgPSB7CiAgICAgICAgICAgICAgICAgICAgdG9wOiB0aGlzLnNjYWxlTWFyZ2luVG9wLAogICAgICAgICAgICAgICAgICAgIGJvdHRvbTogdGhpcy5zY2FsZU1hcmdpbkJvdHRvbSwKICAgICAgICAgICAgICAgIH07CiAgICAgICAgICAgIH0KCiAgICAgICAgICAgIHRoaXMuX2NoYXJ0ID0gY3JlYXRlQ2hhcnQodGhpcy4kcmVmcy5jaGFydENvbnRhaW5lciwgdGhpcy5jaGFydE9wdGlvbnMpOwoKICAgICAgICAgICAgdGhpcy5pbml0U2VyaWVzKCk7CiAgICAgICAgfSwKCiAgICAgICAgaW5pdFNlcmllcygpIHsKICAgICAgICAgICAgdGhpcy5fc2VyaWVzID0ge307CgogICAgICAgICAgICBPYmplY3Qua2V5cyh0aGlzLmNTZXJpZXMpLmZvckVhY2goKF9zZXJpZXNLZXkpID0+IHsKICAgICAgICAgICAgICAgIHRoaXMuYWRkU2VyaWVzKF9zZXJpZXNLZXkpOwogICAgICAgICAgICB9KTsKCiAgICAgICAgICAgIHRoaXMudXBkYXRlQ29sb3JzKCk7CgogICAgICAgICAgICBpZiAodGhpcy5maXRDb250ZW50KSB7CiAgICAgICAgICAgICAgICB0aGlzLl9jaGFydC50aW1lU2NhbGUoKS5maXRDb250ZW50KCk7CiAgICAgICAgICAgIH0KICAgICAgICB9LAoKICAgICAgICBhZGRTZXJpZXMoX3Nlcmllc0tleSkgewogICAgICAgICAgICBjb25zdCBjaGFydCA9IHRoaXMuX2NoYXJ0OwogICAgICAgICAgICBjb25zdCBzZXJpZXNPYmogPSB0aGlzLmNTZXJpZXNbX3Nlcmllc0tleV07CgogICAgICAgICAgICBpZiAoIWNoYXJ0IHx8ICFzZXJpZXNPYmopIHsKICAgICAgICAgICAgICAgIHJldHVybjsKICAgICAgICAgICAgfQoKICAgICAgICAgICAgY29uc3QgZGVmYXVsdFNlcmllc09wdGlvbnMgPSB7CiAgICAgICAgICAgICAgICAvLyBjb2xvcjogdGhpcy5jb2xvciwKICAgICAgICAgICAgfTsKICAgICAgICAgICAgY29uc3Qgc2VyaWVzT3B0aW9ucyA9IHsKICAgICAgICAgICAgICAgIC4uLmRlZmF1bHRTZXJpZXNPcHRpb25zLAogICAgICAgICAgICAgICAgLi4uc2VyaWVzT2JqLnNlcmllc09wdGlvbnMsCiAgICAgICAgICAgIH07CiAgICAgICAgICAgIGxldCBzZXJpZXMgPSBudWxsOwoKICAgICAgICAgICAgc3dpdGNoIChzZXJpZXNPYmouc2VyaWVzVHlwZSkgewogICAgICAgICAgICAgICAgY2FzZSAnbGluZSc6CiAgICAgICAgICAgICAgICAgICAgc2VyaWVzID0gY2hhcnQuYWRkTGluZVNlcmllcyhzZXJpZXNPcHRpb25zKTsKICAgICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgIGNhc2UgJ2hpc3RvZ3JhbSc6CiAgICAgICAgICAgICAgICAgICAgc2VyaWVzID0gY2hhcnQuYWRkSGlzdG9ncmFtU2VyaWVzKHNlcmllc09wdGlvbnMpOwogICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgY2FzZSAnYXJlYSc6CiAgICAgICAgICAgICAgICAgICAgc2VyaWVzID0gY2hhcnQuYWRkQXJlYVNlcmllcyhzZXJpZXNPcHRpb25zKTsKICAgICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgIGNhc2UgJ2Jhcic6CiAgICAgICAgICAgICAgICAgICAgc2VyaWVzID0gY2hhcnQuYWRkQmFyU2VyaWVzKHNlcmllc09wdGlvbnMpOwogICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgY2FzZSAnY2FuZGxlc3RpY2snOgogICAgICAgICAgICAgICAgICAgIHNlcmllcyA9IGNoYXJ0LmFkZENhbmRsZXN0aWNrU2VyaWVzKHNlcmllc09wdGlvbnMpOwogICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICB9CgogICAgICAgICAgICBpZiAoc2VyaWVzKSB7CiAgICAgICAgICAgICAgICBzZXJpZXMuc2V0RGF0YShzZXJpZXNPYmouc2VyaWVzKTsKICAgICAgICAgICAgICAgIHRoaXMuX3Nlcmllc1tfc2VyaWVzS2V5XSA9IHNlcmllczsKICAgICAgICAgICAgfQogICAgICAgIH0sCgogICAgICAgIHRyYW5zZm9ybVZhbHVlc1RvTkVYVChfc2VyaWVzKSB7CiAgICAgICAgICAgIGxldCBkYXRhID0gW107CiAgICAgICAgICAgIGxldCBpdGVtOwoKICAgICAgICAgICAgaWYgKF9zZXJpZXMpIHsKICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4xID0gX3Nlcmllcy5sZW5ndGg7IGkgPCBsZW4xOyBpKyspIHsKICAgICAgICAgICAgICAgICAgICBpdGVtID0gX3Nlcmllc1tpXTsKCiAgICAgICAgICAgICAgICAgICAgZGF0YS5wdXNoKHsKICAgICAgICAgICAgICAgICAgICAgICAgLi4uaXRlbSwKICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHBhcnNlSW50KGl0ZW0udmFsdWUsIDE2KSAvIFdFSSwKICAgICAgICAgICAgICAgICAgICB9KTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQoKICAgICAgICAgICAgcmV0dXJuIGRhdGE7CiAgICAgICAgfSwKCiAgICAgICAgdHJhbnNmb3JtVGltZVRvVGltZXN0YW1wKF9zZXJpZXMpIHsKICAgICAgICAgICAgbGV0IGRhdGU7CgogICAgICAgICAgICBpZiAoX3NlcmllcykgewogICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbjEgPSBfc2VyaWVzLmxlbmd0aDsgaSA8IGxlbjE7IGkrKykgewogICAgICAgICAgICAgICAgICAgIGRhdGUgPSBuZXcgRGF0ZShfc2VyaWVzW2ldLnRpbWUpOwogICAgICAgICAgICAgICAgICAgIF9zZXJpZXNbaV0udGltZSA9IE1hdGguZmxvb3IoZGF0ZS5nZXRUaW1lKCkgLyAxMDAwKTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQogICAgICAgIH0sCgogICAgICAgIGluamVjdE1pc3NpbmdWYWx1ZXMoX3NlcmllcywgX29wdGlvbnMpIHsKICAgICAgICAgICAgbGV0IGRhdGEgPSBbXTsKICAgICAgICAgICAgbGV0IHByZXZJdGVtOwogICAgICAgICAgICBsZXQgaXRlbTsKICAgICAgICAgICAgbGV0IGRpZmYgPSAwOwogICAgICAgICAgICBjb25zdCB7IHRpbWVSZXNvbHV0aW9uIH0gPSBfb3B0aW9uczsKICAgICAgICAgICAgY29uc3QgeyB2YWx1ZSB9ID0gX29wdGlvbnM7CiAgICAgICAgICAgIGNvbnN0IHVzZUxhc3RWYWx1ZSA9IHZhbHVlID09PSAnbGFzdCc7CgogICAgICAgICAgICBpZiAoX3NlcmllcyAmJiB0aW1lUmVzb2x1dGlvbiA+IDApIHsKICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4xID0gX3Nlcmllcy5sZW5ndGg7IGkgPCBsZW4xOyBpKyspIHsKICAgICAgICAgICAgICAgICAgICBpdGVtID0gX3Nlcmllc1tpXTsKCiAgICAgICAgICAgICAgICAgICAgaWYgKGkgPiAwKSB7CiAgICAgICAgICAgICAgICAgICAgICAgIHByZXZJdGVtID0gX3Nlcmllc1tpIC0gMV07CiAgICAgICAgICAgICAgICAgICAgICAgIGRpZmYgPSBpdGVtLnRpbWUgLSBwcmV2SXRlbS50aW1lOwogICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGlmZiA+IHRpbWVSZXNvbHV0aW9uKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMSwgbGVuMiA9IHBhcnNlSW50KGRpZmYgLyB0aW1lUmVzb2x1dGlvbik7IGogPCBsZW4yOyBqKyspIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLnB1c2goewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lOiBwcmV2SXRlbS50aW1lICsgaiAqIHRpbWVSZXNvbHV0aW9uLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdXNlTGFzdFZhbHVlID8gcHJldkl0ZW0udmFsdWUgOiB2YWx1ZSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgICAgICAgZGF0YS5wdXNoKHsgLi4uaXRlbSB9KTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQoKICAgICAgICAgICAgcmV0dXJuIGRhdGE7CiAgICAgICAgfSwKCiAgICAgICAgdXBkYXRlQ29sb3JzKCkgewogICAgICAgICAgICBjb25zdCBjaGFydENQID0gdGhpcy5nZXRDaGFydEN1c3RvbVByb3BlcnRpZXMoKTsKICAgICAgICAgICAgY29uc3Qgc2VyaWVzID0gdGhpcy5fc2VyaWVzOwogICAgICAgICAgICBjb25zdCB7IGNTZXJpZXMgfSA9IHRoaXM7CiAgICAgICAgICAgIGNvbnN0IHsgY2hhcnRPcHRpb25zIH0gPSB0aGlzOwogICAgICAgICAgICBjb25zdCBvcHRpb25zID0gewogICAgICAgICAgICAgICAgZ3JpZDoge30sCiAgICAgICAgICAgICAgICBsYXlvdXQ6IHt9LAogICAgICAgICAgICAgICAgdGltZVNjYWxlOiB7fSwKICAgICAgICAgICAgICAgIHByaWNlU2NhbGU6IHt9LAogICAgICAgICAgICB9OwogICAgICAgICAgICBjb25zdCBncmlkID0geyAuLi5jaGFydE9wdGlvbnMuZ3JpZCB9OwogICAgICAgICAgICBjb25zdCBsYXlvdXQgPSB7IC4uLmNoYXJ0T3B0aW9ucy5sYXlvdXQgfTsKICAgICAgICAgICAgY29uc3QgdGltZVNjYWxlID0geyAuLi5jaGFydE9wdGlvbnMudGltZVNjYWxlIH07CiAgICAgICAgICAgIGNvbnN0IHByaWNlU2NhbGUgPSB7IC4uLmNoYXJ0T3B0aW9ucy5wcmljZVNjYWxlIH07CgogICAgICAgICAgICBpZiAoY2hhcnRDUC52ZXJ0TGluZXNDb2xvciAmJiAoIWdyaWQudmVydExpbmVzIHx8ICFncmlkLnZlcnRMaW5lcy5jb2xvcikpIHsKICAgICAgICAgICAgICAgIG9wdGlvbnMuZ3JpZC52ZXJ0TGluZXMgPSB7IC4uLmdyaWQudmVydExpbmVzLCBjb2xvcjogY2hhcnRDUC52ZXJ0TGluZXNDb2xvciB9OwogICAgICAgICAgICB9CgogICAgICAgICAgICBpZiAoY2hhcnRDUC5ob3J6TGluZXNDb2xvciAmJiAoIWdyaWQuaG9yekxpbmVzIHx8ICFncmlkLmhvcnpMaW5lcy5jb2xvcikpIHsKICAgICAgICAgICAgICAgIG9wdGlvbnMuZ3JpZC5ob3J6TGluZXMgPSB7IC4uLmdyaWQuaG9yekxpbmVzLCBjb2xvcjogY2hhcnRDUC5ob3J6TGluZXNDb2xvciB9OwogICAgICAgICAgICB9CgogICAgICAgICAgICBbJ2JhY2tncm91bmRDb2xvcicsICd0ZXh0Q29sb3InLCAnZm9udFNpemUnLCAnZm9udEZhbWlseSddLmZvckVhY2goKF9wcm9wKSA9PiB7CiAgICAgICAgICAgICAgICBpZiAoY2hhcnRDUFtfcHJvcF0gJiYgIWxheW91dFtfcHJvcF0pIHsKICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmxheW91dFtfcHJvcF0gPSBfcHJvcCA9PT0gJ2ZvbnRTaXplJyA/IHBhcnNlSW50KGNoYXJ0Q1BbX3Byb3BdKSA6IGNoYXJ0Q1BbX3Byb3BdOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICB9KTsKCiAgICAgICAgICAgIGlmIChjaGFydENQLnRpbWVTY2FsZUJvcmRlckNvbG9yICYmICF0aW1lU2NhbGUuYm9yZGVyQ29sb3IpIHsKICAgICAgICAgICAgICAgIG9wdGlvbnMudGltZVNjYWxlLmJvcmRlckNvbG9yID0gY2hhcnRDUC50aW1lU2NhbGVCb3JkZXJDb2xvcjsKICAgICAgICAgICAgfQoKICAgICAgICAgICAgaWYgKGNoYXJ0Q1AucHJpY2VTY2FsZUJvcmRlckNvbG9yICYmICFwcmljZVNjYWxlLmJvcmRlckNvbG9yKSB7CiAgICAgICAgICAgICAgICBvcHRpb25zLnByaWNlU2NhbGUuYm9yZGVyQ29sb3IgPSBjaGFydENQLnByaWNlU2NhbGVCb3JkZXJDb2xvcjsKICAgICAgICAgICAgfQoKICAgICAgICAgICAgdGhpcy5fY2hhcnQuYXBwbHlPcHRpb25zKG9wdGlvbnMpOwoKICAgICAgICAgICAgT2JqZWN0LmtleXMoc2VyaWVzKS5mb3JFYWNoKChfc2VyaWVzS2V5KSA9PiB7CiAgICAgICAgICAgICAgICBjb25zdCBpdGVtID0gY1Nlcmllc1tfc2VyaWVzS2V5XTsKICAgICAgICAgICAgICAgIGNvbnN0IHNlcmllc09wdGlvbnMgPSB7IC4uLml0ZW0uc2VyaWVzT3B0aW9ucyB9OwoKICAgICAgICAgICAgICAgIGlmICghaXRlbSkgewogICAgICAgICAgICAgICAgICAgIHJldHVybjsKICAgICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgICBpZiAoY2hhcnRDUC5saW5lQ29sb3IgJiYgKCFzZXJpZXNPcHRpb25zIHx8ICFzZXJpZXNPcHRpb25zLmNvbG9yKSkgewogICAgICAgICAgICAgICAgICAgIHNlcmllc1tfc2VyaWVzS2V5XS5hcHBseU9wdGlvbnMoewogICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjogY2hhcnRDUC5saW5lQ29sb3IsCiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVDb2xvcjogY2hhcnRDUC5saW5lQ29sb3IsCiAgICAgICAgICAgICAgICAgICAgICAgIHRvcENvbG9yOiBjaGFydENQLnRvcENvbG9yLAogICAgICAgICAgICAgICAgICAgICAgICBib3R0b21Db2xvcjogY2hhcnRDUC5ib3R0b21Db2xvciwKICAgICAgICAgICAgICAgICAgICAgICAgbGluZVdpZHRoOiBjaGFydENQLmxpbmVXaWR0aCwKICAgICAgICAgICAgICAgICAgICB9KTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgfSk7CiAgICAgICAgfSwKCiAgICAgICAgZ2V0Q2hhcnRDdXN0b21Qcm9wZXJ0aWVzKCkgewogICAgICAgICAgICBjb25zdCBzdHlsZSA9IGdldENvbXB1dGVkU3R5bGUodGhpcy4kZWwpOwogICAgICAgICAgICBjb25zdCBjcCA9IHsKICAgICAgICAgICAgICAgIGxpbmVDb2xvcjogc3R5bGUuZ2V0UHJvcGVydHlWYWx1ZSgnLS1mLWxpZ2h0d2VpZ2h0LWNoYXJ0LWNoYXJ0LWxpbmUtY29sb3InKSwKICAgICAgICAgICAgICAgIHRleHRDb2xvcjogc3R5bGUuZ2V0UHJvcGVydHlWYWx1ZSgnLS1mLWxpZ2h0d2VpZ2h0LWNoYXJ0LWNoYXJ0LXRleHQtY29sb3InKSwKICAgICAgICAgICAgICAgIHRvcENvbG9yOiBzdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKCctLWYtbGlnaHR3ZWlnaHQtY2hhcnQtY2hhcnQtdG9wLWNvbG9yJyksCiAgICAgICAgICAgICAgICBib3R0b21Db2xvcjogc3R5bGUuZ2V0UHJvcGVydHlWYWx1ZSgnLS1mLWxpZ2h0d2VpZ2h0LWNoYXJ0LWNoYXJ0LWJvdHRvbS1jb2xvcicpLAogICAgICAgICAgICAgICAgbGluZVdpZHRoOiBzdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKCctLWYtbGlnaHR3ZWlnaHQtY2hhcnQtY2hhcnQtbGluZS13aWR0aCcpLAogICAgICAgICAgICAgICAgdmVydExpbmVzQ29sb3I6IHN0eWxlLmdldFByb3BlcnR5VmFsdWUoJy0tZi1saWdodHdlaWdodC1jaGFydC1jaGFydC12ZXJ0LWxpbmVzLWNvbG9yJyksCiAgICAgICAgICAgICAgICBob3J6TGluZXNDb2xvcjogc3R5bGUuZ2V0UHJvcGVydHlWYWx1ZSgnLS1mLWxpZ2h0d2VpZ2h0LWNoYXJ0LWNoYXJ0LWhvcnotbGluZXMtY29sb3InKSwKICAgICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogc3R5bGUuZ2V0UHJvcGVydHlWYWx1ZSgnLS1mLWxpZ2h0d2VpZ2h0LWNoYXJ0LWNoYXJ0LWJhY2tncm91bmQtY29sb3InKSwKICAgICAgICAgICAgICAgIGZvbnRTaXplOiBzdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKCctLWYtbGlnaHR3ZWlnaHQtY2hhcnQtY2hhcnQtZm9udC1zaXplJyksCiAgICAgICAgICAgICAgICBmb250RmFtaWx5OiBzdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKCctLWYtbGlnaHR3ZWlnaHQtY2hhcnQtY2hhcnQtZm9udC1mYW1pbHknKSwKICAgICAgICAgICAgICAgIHRpbWVTY2FsZUJvcmRlckNvbG9yOiBzdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKCctLWYtbGlnaHR3ZWlnaHQtY2hhcnQtY2hhcnQtdGltZS1zY2FsZS1ib3JkZXItY29sb3InKSwKICAgICAgICAgICAgICAgIHByaWNlU2NhbGVCb3JkZXJDb2xvcjogc3R5bGUuZ2V0UHJvcGVydHlWYWx1ZSgnLS1mLWxpZ2h0d2VpZ2h0LWNoYXJ0LWNoYXJ0LXByaWNlLXNjYWxlLWJvcmRlci1jb2xvcicpLAogICAgICAgICAgICB9OwoKICAgICAgICAgICAgT2JqZWN0LmtleXMoY3ApLmZvckVhY2goKF9rZXkpID0+IHsKICAgICAgICAgICAgICAgIGNvbnN0IGNvbG9yID0gY3BbX2tleV07CgogICAgICAgICAgICAgICAgaWYgKGNvbG9yKSB7CiAgICAgICAgICAgICAgICAgICAgY3BbX2tleV0gPSBjb2xvci50cmltKCk7CiAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBjcFtfa2V5XTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgfSk7CgogICAgICAgICAgICByZXR1cm4gY3A7CiAgICAgICAgfSwKCiAgICAgICAgZGVzdHJveUNoYXJ0KCkgewogICAgICAgICAgICBpZiAodGhpcy5fY2hhcnQpIHsKICAgICAgICAgICAgICAgIHRoaXMuX3NlcmllcyA9IHt9OwogICAgICAgICAgICAgICAgdGhpcy5fY2hhcnQucmVtb3ZlKCk7CiAgICAgICAgICAgICAgICB0aGlzLl9jaGFydCA9IG51bGw7CiAgICAgICAgICAgIH0KICAgICAgICB9LAoKICAgICAgICBvbldpbmRvd1Jlc2l6ZSgpIHsKICAgICAgICAgICAgY29uc3QgY2hhcnQgPSB0aGlzLl9jaGFydDsKCiAgICAgICAgICAgIGlmIChjaGFydCkgewogICAgICAgICAgICAgICAgY2hhcnQucmVzaXplKHRoaXMuJHJlZnMuY2hhcnRDb250YWluZXIuY2xpZW50V2lkdGgsIHRoaXMuaGVpZ2h0KTsKICAgICAgICAgICAgfQogICAgICAgIH0sCiAgICB9LAp9Owo="},{"version":3,"sources":["FLightweightCharts.vue"],"names":[],"mappings":";AASA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA","file":"FLightweightCharts.vue","sourceRoot":"src/components/core/FLightweightCharts","sourcesContent":["<template>\n    <div class=\"f-lightweight-chart\">\n        <slot name=\"top\"></slot>\n        <div ref=\"chartContainer\" class=\"f-lightweight-chart__container\"></div>\n        <slot name=\"bottom\"></slot>\n    </div>\n</template>\n\n<script>\nimport { createChart } from 'lightweight-charts';\nimport { isArray, throttle } from '../../../utils';\n\nconst WEI = 1000000000000000000;\n\n/**\n * Lightweight chart series object.\n * @typedef {Object} LightweightSeries\n * @property {array} series Data for series.\n * @property {('line' | 'histogram' | 'area' | 'bar' | 'candlestick')} seriesType Type of series.\n * @property {('' | 'to-eth')} [transformValues]\n */\n\n/**\n * Lightweight charts wrapper.\n * https://www.tradingview.com/lightweight-charts/\n */\nexport default {\n    name: 'FLightweightCharts',\n\n    props: {\n        /**\n         * Data for chart.\n         * It can be series (array of series data) or object, where keys are unique series ids and values are objects\n         * of type LightweightSeries.\n         * @type {[] | {key: string, series: LightweightSeries}}\n         */\n        series: {\n            type: [Array, Object],\n            default() {\n                return [];\n            },\n        },\n        /**\n         * Type of series.\n         * @type {('line' | 'histogram' | 'area' | 'bar' | 'candlestick')}\n         */\n        seriesType: {\n            type: String,\n            default: 'line',\n            validator: function (_value) {\n                return ['line', 'histogram', 'area', 'bar', 'candlestick'].indexOf(_value) !== -1;\n            },\n        },\n        /** Lightweight chart's options. */\n        options: {\n            type: Object,\n            default() {\n                return {};\n            },\n        },\n        /** Lightweight chart's series options. */\n        seriesOptions: {\n            type: Object,\n            default() {\n                return {};\n            },\n        },\n        /** Chart height. */\n        height: {\n            type: Number,\n            default: 300,\n        },\n        /** Basic line color. */\n        color: {\n            type: String,\n            default: '#2040FF',\n        },\n        /** Default scale top margin */\n        scaleMarginTop: {\n            type: Number,\n            default: 0.1,\n        },\n        /** Default scale bottom margin */\n        scaleMarginBottom: {\n            type: Number,\n            default: 0.03,\n        },\n        /**\n         * @type {('' | 'to-eth')}\n         */\n        transformValues: {\n            type: String,\n            default: '',\n            validator: function (_value) {\n                return ['', 'to-eth'].indexOf(_value) !== -1;\n            },\n        },\n        /** Inject missing values */\n        addMissingValues: {\n            type: Object,\n            default() {\n                return {\n                    timeResolution: 0,\n                    value: 0,\n                };\n            },\n        },\n        /**\n         * Transform given series time to timestamp.\n         */\n        timeToTimestamp: {\n            type: Boolean,\n            default: false,\n        },\n        /**  */\n        fitContent: {\n            type: Boolean,\n            default: false,\n        },\n        /** Disable auto resizing. */\n        noAutoResize: {\n            type: Boolean,\n            default: false,\n        },\n    },\n\n    data() {\n        return {\n            dSeries: [],\n            chartOptions: {},\n        };\n    },\n\n    computed: {\n        cSeries() {\n            const { series } = this;\n            let data = {};\n\n            if (isArray(series)) {\n                data.series = {\n                    seriesType: this.seriesType,\n                    seriesOptions: this.seriesOptions,\n                    transformValues: this.transformValues,\n                    timeToTimestamp: this.timeToTimestamp,\n                    addMissingValues: this.addMissingValues,\n                    series: series,\n                };\n            }\n\n            if (!data.series) {\n                data = { ...series };\n            }\n\n            Object.keys(data).forEach((_seriesKey) => {\n                const item = data[_seriesKey];\n\n                if (item.timeToTimestamp || item.addMissingValues.timeResolution > 0) {\n                    this.transformTimeToTimestamp(item.series);\n                }\n\n                if (item.addMissingValues.timeResolution > 0) {\n                    item.series = this.injectMissingValues(item.series, item.addMissingValues);\n                }\n\n                if (item.transformValues) {\n                    if (item.transformValues === 'to-eth') {\n                        item.series = this.transformValuesToNEXT(item.series);\n                    }\n                }\n            });\n\n            return data;\n        },\n    },\n\n    watch: {\n        series() {\n            this.initChart();\n            // this.initSeries();\n        },\n    },\n\n    created() {\n        /** Lightweight chart instance. */\n        this._chart = null;\n        /** Array of Lightweight chart series instances. */\n        this._series = {};\n        /** Debounce function used as window resize callback. */\n        this._resizeCallback = throttle((_event) => this.onWindowResize(_event), 300, true);\n    },\n\n    mounted() {\n        // this.initChart();\n\n        if (!this.noAutoResize) {\n            window.addEventListener('resize', this._resizeCallback, false);\n        }\n    },\n\n    beforeDestroy() {\n        this.destroyChart();\n\n        if (!this.noAutoResize) {\n            window.removeEventListener('resize', this._resizeCallback);\n        }\n    },\n\n    methods: {\n        initChart() {\n            const defaultOptions = {\n                height: this.height,\n                priceScale: {},\n            };\n\n            this.destroyChart();\n\n            this.chartOptions = {\n                ...defaultOptions,\n                ...this.options,\n            };\n\n            if (!this.chartOptions.priceScale.scaleMargins) {\n                this.chartOptions.priceScale.scaleMargins = {\n                    top: this.scaleMarginTop,\n                    bottom: this.scaleMarginBottom,\n                };\n            }\n\n            this._chart = createChart(this.$refs.chartContainer, this.chartOptions);\n\n            this.initSeries();\n        },\n\n        initSeries() {\n            this._series = {};\n\n            Object.keys(this.cSeries).forEach((_seriesKey) => {\n                this.addSeries(_seriesKey);\n            });\n\n            this.updateColors();\n\n            if (this.fitContent) {\n                this._chart.timeScale().fitContent();\n            }\n        },\n\n        addSeries(_seriesKey) {\n            const chart = this._chart;\n            const seriesObj = this.cSeries[_seriesKey];\n\n            if (!chart || !seriesObj) {\n                return;\n            }\n\n            const defaultSeriesOptions = {\n                // color: this.color,\n            };\n            const seriesOptions = {\n                ...defaultSeriesOptions,\n                ...seriesObj.seriesOptions,\n            };\n            let series = null;\n\n            switch (seriesObj.seriesType) {\n                case 'line':\n                    series = chart.addLineSeries(seriesOptions);\n                    break;\n                case 'histogram':\n                    series = chart.addHistogramSeries(seriesOptions);\n                    break;\n                case 'area':\n                    series = chart.addAreaSeries(seriesOptions);\n                    break;\n                case 'bar':\n                    series = chart.addBarSeries(seriesOptions);\n                    break;\n                case 'candlestick':\n                    series = chart.addCandlestickSeries(seriesOptions);\n                    break;\n            }\n\n            if (series) {\n                series.setData(seriesObj.series);\n                this._series[_seriesKey] = series;\n            }\n        },\n\n        transformValuesToNEXT(_series) {\n            let data = [];\n            let item;\n\n            if (_series) {\n                for (let i = 0, len1 = _series.length; i < len1; i++) {\n                    item = _series[i];\n\n                    data.push({\n                        ...item,\n                        value: parseInt(item.value, 16) / WEI,\n                    });\n                }\n            }\n\n            return data;\n        },\n\n        transformTimeToTimestamp(_series) {\n            let date;\n\n            if (_series) {\n                for (let i = 0, len1 = _series.length; i < len1; i++) {\n                    date = new Date(_series[i].time);\n                    _series[i].time = Math.floor(date.getTime() / 1000);\n                }\n            }\n        },\n\n        injectMissingValues(_series, _options) {\n            let data = [];\n            let prevItem;\n            let item;\n            let diff = 0;\n            const { timeResolution } = _options;\n            const { value } = _options;\n            const useLastValue = value === 'last';\n\n            if (_series && timeResolution > 0) {\n                for (let i = 0, len1 = _series.length; i < len1; i++) {\n                    item = _series[i];\n\n                    if (i > 0) {\n                        prevItem = _series[i - 1];\n                        diff = item.time - prevItem.time;\n                        if (diff > timeResolution) {\n                            for (let j = 1, len2 = parseInt(diff / timeResolution); j < len2; j++) {\n                                data.push({\n                                    time: prevItem.time + j * timeResolution,\n                                    value: useLastValue ? prevItem.value : value,\n                                });\n                            }\n                        }\n                    }\n\n                    data.push({ ...item });\n                }\n            }\n\n            return data;\n        },\n\n        updateColors() {\n            const chartCP = this.getChartCustomProperties();\n            const series = this._series;\n            const { cSeries } = this;\n            const { chartOptions } = this;\n            const options = {\n                grid: {},\n                layout: {},\n                timeScale: {},\n                priceScale: {},\n            };\n            const grid = { ...chartOptions.grid };\n            const layout = { ...chartOptions.layout };\n            const timeScale = { ...chartOptions.timeScale };\n            const priceScale = { ...chartOptions.priceScale };\n\n            if (chartCP.vertLinesColor && (!grid.vertLines || !grid.vertLines.color)) {\n                options.grid.vertLines = { ...grid.vertLines, color: chartCP.vertLinesColor };\n            }\n\n            if (chartCP.horzLinesColor && (!grid.horzLines || !grid.horzLines.color)) {\n                options.grid.horzLines = { ...grid.horzLines, color: chartCP.horzLinesColor };\n            }\n\n            ['backgroundColor', 'textColor', 'fontSize', 'fontFamily'].forEach((_prop) => {\n                if (chartCP[_prop] && !layout[_prop]) {\n                    options.layout[_prop] = _prop === 'fontSize' ? parseInt(chartCP[_prop]) : chartCP[_prop];\n                }\n            });\n\n            if (chartCP.timeScaleBorderColor && !timeScale.borderColor) {\n                options.timeScale.borderColor = chartCP.timeScaleBorderColor;\n            }\n\n            if (chartCP.priceScaleBorderColor && !priceScale.borderColor) {\n                options.priceScale.borderColor = chartCP.priceScaleBorderColor;\n            }\n\n            this._chart.applyOptions(options);\n\n            Object.keys(series).forEach((_seriesKey) => {\n                const item = cSeries[_seriesKey];\n                const seriesOptions = { ...item.seriesOptions };\n\n                if (!item) {\n                    return;\n                }\n\n                if (chartCP.lineColor && (!seriesOptions || !seriesOptions.color)) {\n                    series[_seriesKey].applyOptions({\n                        color: chartCP.lineColor,\n                        lineColor: chartCP.lineColor,\n                        topColor: chartCP.topColor,\n                        bottomColor: chartCP.bottomColor,\n                        lineWidth: chartCP.lineWidth,\n                    });\n                }\n            });\n        },\n\n        getChartCustomProperties() {\n            const style = getComputedStyle(this.$el);\n            const cp = {\n                lineColor: style.getPropertyValue('--f-lightweight-chart-chart-line-color'),\n                textColor: style.getPropertyValue('--f-lightweight-chart-chart-text-color'),\n                topColor: style.getPropertyValue('--f-lightweight-chart-chart-top-color'),\n                bottomColor: style.getPropertyValue('--f-lightweight-chart-chart-bottom-color'),\n                lineWidth: style.getPropertyValue('--f-lightweight-chart-chart-line-width'),\n                vertLinesColor: style.getPropertyValue('--f-lightweight-chart-chart-vert-lines-color'),\n                horzLinesColor: style.getPropertyValue('--f-lightweight-chart-chart-horz-lines-color'),\n                backgroundColor: style.getPropertyValue('--f-lightweight-chart-chart-background-color'),\n                fontSize: style.getPropertyValue('--f-lightweight-chart-chart-font-size'),\n                fontFamily: style.getPropertyValue('--f-lightweight-chart-chart-font-family'),\n                timeScaleBorderColor: style.getPropertyValue('--f-lightweight-chart-chart-time-scale-border-color'),\n                priceScaleBorderColor: style.getPropertyValue('--f-lightweight-chart-chart-price-scale-border-color'),\n            };\n\n            Object.keys(cp).forEach((_key) => {\n                const color = cp[_key];\n\n                if (color) {\n                    cp[_key] = color.trim();\n                } else {\n                    delete cp[_key];\n                }\n            });\n\n            return cp;\n        },\n\n        destroyChart() {\n            if (this._chart) {\n                this._series = {};\n                this._chart.remove();\n                this._chart = null;\n            }\n        },\n\n        onWindowResize() {\n            const chart = this._chart;\n\n            if (chart) {\n                chart.resize(this.$refs.chartContainer.clientWidth, this.height);\n            }\n        },\n    },\n};\n</script>\n\n<style lang=\"scss\">\n@import 'style';\n</style>\n"]}]}