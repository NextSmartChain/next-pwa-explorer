{"remainingRequest":"/mnt/websites/ex.nextsmartchain.com/node_modules/thread-loader/dist/cjs.js!/mnt/websites/ex.nextsmartchain.com/node_modules/babel-loader/lib/index.js!/mnt/websites/ex.nextsmartchain.com/node_modules/eslint-loader/index.js??ref--14-0!/mnt/websites/ex.nextsmartchain.com/src/utils/tree.js","dependencies":[{"path":"/mnt/websites/ex.nextsmartchain.com/src/utils/tree.js","mtime":1657708590038},{"path":"/mnt/websites/ex.nextsmartchain.com/babel.config.js","mtime":1657708595230},{"path":"/mnt/websites/ex.nextsmartchain.com/node_modules/cache-loader/dist/cjs.js","mtime":1655491106804},{"path":"/mnt/websites/ex.nextsmartchain.com/node_modules/thread-loader/dist/cjs.js","mtime":1655491285854},{"path":"/mnt/websites/ex.nextsmartchain.com/node_modules/babel-loader/lib/index.js","mtime":1655491285588},{"path":"/mnt/websites/ex.nextsmartchain.com/node_modules/eslint-loader/index.js","mtime":1655491290241}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:aW1wb3J0IF9jbGFzc0NhbGxDaGVjayBmcm9tICIvbW50L3dlYnNpdGVzL2V4Lm5leHRzbWFydGNoYWluLmNvbS9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vY2xhc3NDYWxsQ2hlY2suanMiOwppbXBvcnQgX2NyZWF0ZUNsYXNzIGZyb20gIi9tbnQvd2Vic2l0ZXMvZXgubmV4dHNtYXJ0Y2hhaW4uY29tL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9jcmVhdGVDbGFzcy5qcyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LnNwbGljZS5qcyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy50cmltLmpzIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMucmVnZXhwLmV4ZWMuanMiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcuc3BsaXQuanMiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5qb2luLmpzIjsKaW1wb3J0IHsgaXNBcnJheSwgaW5BcnJheSB9IGZyb20gIi4vaW5kZXguanMiOwppbXBvcnQgc2hvcnRpZCBmcm9tICdzaG9ydGlkJzsKZXhwb3J0IHZhciBUcmVlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHsKICBmdW5jdGlvbiBUcmVlKF9kYXRhLCBfb3B0aW9ucykgewogICAgdmFyIF90aGlzID0gdGhpczsKCiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgVHJlZSk7CgogICAgdGhpcy5fb3B0aW9ucyA9IHsKICAgICAgLy8geW91IGNhbid0IGluc2VydCBvciByZW1vdmUgdHJlZSBpdGVtCiAgICAgIC8vIHJlYWRPbmx5OiB0cnVlLAogICAgICAvLyBpZFByZWZpeDogJ2knLAogICAgICBkYXRhOiBudWxsLAogICAgICB3YWxrVHlwZTogJ25vcm1hbCcsCiAgICAgIHBhdGhDb2RlOiAnX3R5cGUnLAogICAgICBwcmVwYXJlRGF0YTogdHJ1ZSwKICAgICAgYWRkSWQ6IGZhbHNlLAogICAgICBfYWRkSWQ6IGZhbHNlLAogICAgICBjaGVja0NoYW5nZXNPblVwZGF0ZTogZmFsc2UsCiAgICAgIC8vIGZ1bmN0aW9uCiAgICAgIG9uRGF0YU5vZGU6IG51bGwsCiAgICAgIG9uRGF0YVdyYXA6IG51bGwsCiAgICAgIG9uQmVmb3JlTm9kZVJlbW92ZTogbnVsbCwKICAgICAgb25CZWZvcmVEYXRhTm9kZTogbnVsbCwKICAgICAgb25CZWZvcmVEYXRhUmVtb3ZlOiBudWxsCiAgICB9OwogICAgT2JqZWN0LmFzc2lnbih0aGlzLl9vcHRpb25zLCBfb3B0aW9ucyk7CiAgICB2YXIgb3B0aW9ucyA9IHRoaXMuX29wdGlvbnM7CiAgICAvKiogUm9vdCBvZiB0aGUgdHJlZS4gKi8KCiAgICB0aGlzLnJvb3QgPSB7CiAgICAgIC8vIGlkOiAnX3Jvb3QnLAogICAgICBfYzogW10sCiAgICAgIC8vIGNoaWxkcmVuCiAgICAgIF9wOiBudWxsLAogICAgICAvLyBwYXJlbnQKICAgICAgX2w6IC0xIC8vIGxldmVsCgogICAgfTsKICAgIC8qKiBLZXlzIGFyZSBpZHMgKHJvdy5pZCBvciByb3dbMF0pLCB2YWx1ZXMgYXJlIHJlZmVyZW5jZXMgdG8gYHRoaXMucm9vdGAgYXJyYXkgaXRlbXMuICovCgogICAgdGhpcy5kYXRhTCA9IHt9OwogICAgLyoqIFBvaW50ZXIgdG8gYWN0dWFsIG5vZGUuICovCgogICAgdGhpcy5fY3Vyc29yID0gdGhpcy5yb290OwogICAgLyoqIE9wdGlvbnMgZm9yIHJlbW92ZSB3YWxraW5nLiAqLwoKICAgIHRoaXMucmVtb3ZlV2Fsa09wdGlvbnMgPSB7CiAgICAgIHdhbGtUeXBlOiAncmVuZGVyJywKICAgICAgb25EYXRhTm9kZTogZnVuY3Rpb24gb25EYXRhTm9kZShfbm9kZSkgewogICAgICAgIHZhciBpZCA9ICcnOwoKICAgICAgICBpZiAob3B0aW9ucy5vbkJlZm9yZU5vZGVSZW1vdmUpIHsKICAgICAgICAgIG9wdGlvbnMub25CZWZvcmVOb2RlUmVtb3ZlKF9ub2RlKTsKICAgICAgICB9CgogICAgICAgIGlmIChvcHRpb25zLnByZXBhcmVEYXRhKSB7CiAgICAgICAgICBpZiAob3B0aW9ucy5vbkJlZm9yZURhdGFSZW1vdmUpIHsKICAgICAgICAgICAgb3B0aW9ucy5vbkJlZm9yZURhdGFSZW1vdmUoX25vZGUpOwogICAgICAgICAgfQoKICAgICAgICAgIGlkID0gX3RoaXMuZ2V0Tm9kZUlkKF9ub2RlKTsKCiAgICAgICAgICBpZiAoaWQpIHsKICAgICAgICAgICAgZGVsZXRlIF90aGlzLmRhdGFMW2lkXTsKICAgICAgICAgIH0KICAgICAgICB9CgogICAgICAgIGlmIChfbm9kZS5fYykgewogICAgICAgICAgX25vZGUuX2MgPSBudWxsOwogICAgICAgIH0KCiAgICAgICAgcmV0dXJuICcnOwogICAgICB9LAogICAgICBvbkRhdGFXcmFwOiBmdW5jdGlvbiBvbkRhdGFXcmFwKCkge30sCiAgICAgIG9uQmVmb3JlRGF0YU5vZGU6IG9wdGlvbnMub25CZWZvcmVEYXRhTm9kZVJlbW92ZSB8fCBudWxsCiAgICB9OwoKICAgIGlmIChvcHRpb25zLmFkZElkKSB7CiAgICAgIG9wdGlvbnMuX2FkZElkID0gdHJ1ZTsKICAgIH0KCiAgICB0aGlzLnNldERhdGEoX2RhdGEgfHwgW10pOwogIH0KCiAgX2NyZWF0ZUNsYXNzKFRyZWUsIFt7CiAgICBrZXk6ICJfZGVzdHJ1Y3RvciIsCiAgICB2YWx1ZTogZnVuY3Rpb24gX2Rlc3RydWN0b3IoKSB7CiAgICAgIHRoaXMucmVtb3ZlKHRoaXMucm9vdCk7CiAgICB9CiAgICAvKioKICAgICAqIFNldCBuZXcgZGF0YS4KICAgICAqCiAgICAgKiBAcGFyYW0ge2FycmF5fSBfZGF0YSBUcmVlIGRhdGEuCiAgICAgKiBAcmV0dXJuIHt2b2lkfQogICAgICovCgogIH0sIHsKICAgIGtleTogInNldERhdGEiLAogICAgdmFsdWU6IGZ1bmN0aW9uIHNldERhdGEoX2RhdGEpIHsKICAgICAgaWYgKGlzQXJyYXkoX2RhdGEpKSB7CiAgICAgICAgaWYgKHRoaXMucm9vdC5fYy5sZW5ndGggPiAwKSB7CiAgICAgICAgICB0aGlzLmNsZWFyKHRydWUpOwogICAgICAgIH0KCiAgICAgICAgdGhpcy5yb290Ll9jID0gX2RhdGE7CgogICAgICAgIGlmICh0aGlzLl9vcHRpb25zLnByZXBhcmVEYXRhKSB7CiAgICAgICAgICB0aGlzLnByZXBhcmUoKTsKICAgICAgICB9CiAgICAgIH0KICAgIH0KICAgIC8qKgogICAgICogV2FsayBkYXRhIGFuZCBhZGQgbGV2ZWwgYW5kIHBhcmVudCBpbmZvcm1hdGlvbnMgdG8gbm9kZSBhbmQgY3JlYXRlIGB0aGlzLmRhdGFMYCBvYmplY3QuCiAgICAgKgogICAgICogQHBhcmFtIHtvYmplY3R9IFtfbm9kZV0gU3RhcnQgcHJlcGFyaW5nIGRhdGEgZnJvbSBub2RlIGBfbm9kZWAuCiAgICAgKiBAcmV0dXJuIHt2b2lkfQogICAgICovCgogIH0sIHsKICAgIGtleTogInByZXBhcmUiLAogICAgdmFsdWU6IGZ1bmN0aW9uIHByZXBhcmUoX25vZGUpIHsKICAgICAgdmFyIGl0ZW0gPSBudWxsOwogICAgICB2YXIgb3B0aW9ucyA9IHRoaXMuX29wdGlvbnM7CiAgICAgIHZhciBub2RlID0gbnVsbDsKICAgICAgdmFyIGRhdGFMID0gdGhpcy5kYXRhTDsKCiAgICAgIGlmIChfbm9kZSkgewogICAgICAgIGl0ZW0gPSBfbm9kZTsKCiAgICAgICAgaWYgKG9wdGlvbnMuX2FkZElkICYmIGl0ZW0uaWQgPT09IHVuZGVmaW5lZCkgewogICAgICAgICAgaXRlbS5pZCA9IHRoaXMuX2dldElkKCk7IC8vICdkbicgKyB0aGlzLl9jbnRyKys7CgogICAgICAgICAgaWYgKGRhdGFMW2l0ZW0uaWRdICE9PSB1bmRlZmluZWQpIHsKICAgICAgICAgICAgZG8gewogICAgICAgICAgICAgIGl0ZW0uaWQgPSB0aGlzLl9nZXRJZCgpOyAvLyAnZG4nICsgdGhpcy5fY250cisrOwogICAgICAgICAgICB9IHdoaWxlIChkYXRhTFtpdGVtLmlkXSAhPT0gdW5kZWZpbmVkKTsKICAgICAgICAgIH0KCiAgICAgICAgICBkYXRhTFtpdGVtLmlkXSA9IF9ub2RlOwogICAgICAgIH0KICAgICAgfQoKICAgICAgaWYgKF9ub2RlKSB7CiAgICAgICAgbm9kZSA9IF9ub2RlOwogICAgICB9IGVsc2UgewogICAgICAgIG5vZGUgPSB0aGlzLnJvb3Q7CgogICAgICAgIGlmIChub2RlLmlkID09PSB1bmRlZmluZWQgJiYgb3B0aW9ucy5fYWRkSWQpIHsKICAgICAgICAgIG5vZGUuaWQgPSAnX3Jvb3QnOwogICAgICAgICAgZGF0YUxbbm9kZS5pZF0gPSBub2RlOwogICAgICAgIH0KICAgICAgfQoKICAgICAgdGhpcy5fcHJlcGFyZShub2RlKTsKICAgIH0KICAgIC8qKgogICAgICogR2V0IHVuaXF1ZSBpZC4KICAgICAqCiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9CiAgICAgKiBAcHJpdmF0ZQogICAgICovCgogIH0sIHsKICAgIGtleTogIl9nZXRJZCIsCiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldElkKCkgewogICAgICByZXR1cm4gc2hvcnRpZC5nZW5lcmF0ZSgpOwogICAgfQogICAgLyoqCiAgICAgKiBXYWxrIGRhdGEgYW5kIGFkZCBsZXZlbCBhbmQgcGFyZW50IGluZm9ybWF0aW9ucyB0byBub2RlCiAgICAgKiBhbmQgY3JlYXRlIGB0aGlzLmRhdGFMYCBvYmplY3QuCiAgICAgKgogICAgICogQHBhcmFtIHtvYmplY3R9IF9ub2RlCiAgICAgKiBAcGFyYW0ge2ludH0gW19sZXZlbF0KICAgICAqIEByZXR1cm4ge3ZvaWR9CiAgICAgKiBAYXBpIHByaXZhdGUKICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJfcHJlcGFyZSIsCiAgICB2YWx1ZTogZnVuY3Rpb24gX3ByZXBhcmUoX25vZGUsIF9sZXZlbCkgewogICAgICB2YXIgY2hpbGRyZW4gPSBfbm9kZSAmJiBfbm9kZS5fYyA/IF9ub2RlLl9jIDogW107CiAgICAgIHZhciBvcHRpb25zID0gdGhpcy5fb3B0aW9uczsKICAgICAgdmFyIGFkZElkID0gb3B0aW9ucy5fYWRkSWQ7CiAgICAgIHZhciBwcmVzZXJ2ZUlkID0gb3B0aW9ucy5wcmVzZXJ2ZUlkOwogICAgICB2YXIgbm9kZSA9IG51bGw7CiAgICAgIHZhciBpdGVtID0gbnVsbDsKICAgICAgdmFyIGxldmVsID0gX2xldmVsID09PSB1bmRlZmluZWQgJiYgX25vZGUgPyBfbm9kZS5fbCArIDEgOiBfbGV2ZWw7CiAgICAgIHZhciBpZDsgLy8gcmVhZE9ubHkgPSB0aGlzLl9vcHRpb25zLnJlYWRPbmx5LAogICAgICAvLyBvbkRhdGFOb2RlID0gdGhpcy5vbkRhdGFOb2RlLAoKICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7CiAgICAgICAgbm9kZSA9IGNoaWxkcmVuW2ldOwoKICAgICAgICBpZiAoIW5vZGUpIHsKICAgICAgICAgIC8vIElFOCBiaXRjaAogICAgICAgICAgY29udGludWU7CiAgICAgICAgfQoKICAgICAgICBpdGVtID0gbm9kZTsKCiAgICAgICAgaWYgKGFkZElkKSB7CiAgICAgICAgICBpZiAoIShwcmVzZXJ2ZUlkICYmIGl0ZW0uaWQpKSB7CiAgICAgICAgICAgIGl0ZW0uaWQgPSB0aGlzLl9nZXRJZCgpOyAvLyAnZG4nICsgdGhpcy5fY250cisrOwogICAgICAgICAgfQogICAgICAgICAgLyogZWxzZSB7CiAgICAgICAgICAgIHRoaXMuX2NudHIrKzsKICAgICAgICAgIH0gKi8KCiAgICAgICAgfQoKICAgICAgICBub2RlLl9wID0gX25vZGU7CiAgICAgICAgbm9kZS5fbCA9IGxldmVsOwogICAgICAgIGlkID0gaXRlbS5pZDsKICAgICAgICB0aGlzLmRhdGFMW2lkXSA9IG5vZGU7CgogICAgICAgIGlmIChub2RlLl9jKSB7CiAgICAgICAgICB0aGlzLl9wcmVwYXJlKG5vZGUpOwogICAgICAgIH0KICAgICAgfQogICAgfQogICAgLyoqCiAgICAgKiBQcmVwYXJlIGp1c3Qgb25lIG5vZGUuCiAgICAgKgogICAgICogQHBhcmFtIHtvYmplY3R9IF9ub2RlCiAgICAgKiBAcGFyYW0ge29iamVjdH0gX3BhcmVudCBQYGFyZW50YCBub2RlLgogICAgICogQHJldHVybiB7dm9pZH0KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJwcmVwYXJlTm9kZSIsCiAgICB2YWx1ZTogZnVuY3Rpb24gcHJlcGFyZU5vZGUoX25vZGUsIF9wYXJlbnQpIHsKICAgICAgdmFyIGlkOwogICAgICBfbm9kZS5fcCA9IF9wYXJlbnQ7CiAgICAgIF9ub2RlLl9sID0gX3BhcmVudC5fbCArIDE7CiAgICAgIGlkID0gdGhpcy5nZXROb2RlSWQoX25vZGUpOwoKICAgICAgaWYgKGlkKSB7CiAgICAgICAgdGhpcy5kYXRhTFtpZF0gPSBfbm9kZTsKICAgICAgfQogICAgfQogICAgLyoqCiAgICAgKiBDaGVjayB0byBzZWUsIGlmIHRyZWUgaXMgZW1wdHkuCiAgICAgKgogICAgICogQHJldHVybiB7Ym9vbGVhbn0KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJpc0VtcHR5IiwKICAgIHZhbHVlOiBmdW5jdGlvbiBpc0VtcHR5KCkgewogICAgICB2YXIgYyA9IHRoaXMucm9vdC5fYzsKICAgICAgcmV0dXJuICEoYyAmJiBjLmxlbmd0aCA+IDApOwogICAgfQogICAgLyoqCiAgICAgKiBXYWxrIHRyZWUuCiAgICAgKgogICAgICogQHBhcmFtIHtvYmplY3R9IFtfbm9kZV0KICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbX2FyZ3NdCiAgICAgKiBAcGFyYW0ge29iamVjdH0gW19hcmdzMl0KICAgICAqIEByZXR1cm4ge1N0cmluZ3xCb29sZWFufQogICAgICovCgogIH0sIHsKICAgIGtleTogIndhbGsiLAogICAgdmFsdWU6IGZ1bmN0aW9uIHdhbGsoX25vZGUsIF9hcmdzLCBfYXJnczIpIHsKICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLl9vcHRpb25zOwogICAgICB2YXIgYXJncyA9IHsKICAgICAgICBvbkRhdGFOb2RlOiBudWxsLAogICAgICAgIC8vIGZ1bmN0aW9uCiAgICAgICAgb25EYXRhV3JhcDogbnVsbCwKICAgICAgICAvLyBmdW5jdGlvbgogICAgICAgIG9uQmVmb3JlRGF0YU5vZGU6IG51bGwsCiAgICAgICAganVzdENoaWxkcmVuOiBmYWxzZSwKICAgICAgICAvLyBXYWxrIG9uIGNoaWxkcmVuIG9ubHkuCiAgICAgICAgcmVuZGVyU3RhcnROb2RlOiBmYWxzZSwKICAgICAgICBub0ZyaXN0V3JhcDogZmFsc2UsCiAgICAgICAgLy8gZG9uJ3QgcmVuZGVyIGZpcnN0IHdyYXAgZWxlbWVudAogICAgICAgIHdhbGtUeXBlOiAnJyAvLyAnbm9ybWFsJyB8ICdyZW5kZXInCgogICAgICB9OwogICAgICB2YXIgbm9kZSA9IG51bGw7CiAgICAgIHZhciByZXQ7CiAgICAgIE9iamVjdC5hc3NpZ24oYXJncywgX2FyZ3MpOwoKICAgICAgaWYgKGFyZ3Mub25EYXRhTm9kZSA9PT0gbnVsbCkgewogICAgICAgIGFyZ3Mub25EYXRhTm9kZSA9IG9wdGlvbnMub25EYXRhTm9kZTsKICAgICAgfQoKICAgICAgaWYgKGFyZ3Mub25EYXRhV3JhcCA9PT0gbnVsbCkgewogICAgICAgIGFyZ3Mub25EYXRhV3JhcCA9IG9wdGlvbnMub25EYXRhV3JhcDsKICAgICAgfQoKICAgICAgaWYgKGFyZ3Mud2Fsa1R5cGUgPT09ICcnKSB7CiAgICAgICAgYXJncy53YWxrVHlwZSA9IG9wdGlvbnMud2Fsa1R5cGU7CiAgICAgIH0KCiAgICAgIHN3aXRjaCAoYXJncy53YWxrVHlwZSkgewogICAgICAgIGNhc2UgJ25vcm1hbCc6CiAgICAgICAgICAvLyBjYWxsIGBvbkRhdGFXcmFwYCBmdW5jdGlvbiBvbiBgbm9kZWAsIGlmIGl0IGlzIHBhcmVudAogICAgICAgICAgaWYgKG9wdGlvbnMubm9ybWFsV2Fsa1BhcmVudCkgewogICAgICAgICAgICBub2RlID0gX25vZGUgfHwgdGhpcy5yb290OwoKICAgICAgICAgICAgaWYgKG5vZGUgJiYgbm9kZS5fYyAmJiBub2RlLl9jLmxlbmd0aCA+IDApIHsKICAgICAgICAgICAgICBpZiAoYXJncy5vbkRhdGFXcmFwKSB7CiAgICAgICAgICAgICAgICBhcmdzLm9uRGF0YVdyYXAobm9kZSwgX2FyZ3MyKTsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KCiAgICAgICAgICByZXQgPSB0aGlzLl93YWxrTm9ybWFsKF9ub2RlIHx8IHRoaXMucm9vdCwgYXJncywgX2FyZ3MyKTsKICAgICAgICAgIGJyZWFrOwoKICAgICAgICBjYXNlICdyZW5kZXInOgogICAgICAgICAgaWYgKGFyZ3MucmVuZGVyU3RhcnROb2RlKSB7CiAgICAgICAgICAgIF9ub2RlID0gewogICAgICAgICAgICAgIF9jOiBbX25vZGVdCiAgICAgICAgICAgIH07CiAgICAgICAgICB9CgogICAgICAgICAgcmV0ID0gdGhpcy5fd2Fsa1JlbmRlcihfbm9kZSB8fCB0aGlzLnJvb3QsIGFyZ3MsIGFyZ3MucmVuZGVyU3RhcnROb2RlIHx8IGFyZ3Mubm9GcmlzdFdyYXAsIF9hcmdzMik7CiAgICAgICAgICBicmVhazsKCiAgICAgICAgZGVmYXVsdDoKICAgICAgICAgIHJldCA9IGZhbHNlOwogICAgICB9CgogICAgICBhcmdzLm9uRGF0YU5vZGUgPSBudWxsOwogICAgICBhcmdzLm9uRGF0YVdyYXAgPSBudWxsOwogICAgICByZXR1cm4gcmV0OwogICAgfQogICAgLyoqCiAgICAgKiBXYWxrcyB0cmVlIGZyb20gbm9kZSBgX25vZGVgIGRvd253YXJkcyB0byB0aGUgbGVhZnMuCiAgICAgKiBXYWxraW5nIGNhbiBiZSBzdG9wcGVkIGJ5IHJldHVybmluZyBgZmFsc2VgIGluIHRoZSB3YWxrIGZ1bmN0aW9uLgogICAgICoKICAgICAqIEBwYXJhbSB7b2JqZWN0fSBfbm9kZQogICAgICogQHBhcmFtIHtvYmplY3R9IF9hcmdzCiAgICAgKiBAcGFyYW0ge29iamVjdH0gW19hcmdzMl0KICAgICAqIEByZXR1cm4ge3N0cmluZ30KICAgICAqIEBhcGkgcHJpdmF0ZQogICAgICovCgogIH0sIHsKICAgIGtleTogIl93YWxrTm9ybWFsIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBfd2Fsa05vcm1hbChfbm9kZSwgX2FyZ3MsIF9hcmdzMikgewogICAgICB2YXIgY2hpbGRyZW4gPSBfbm9kZSAmJiBfbm9kZS5fYyA/IF9ub2RlLl9jIDogW107CiAgICAgIHZhciBub2RlID0gbnVsbDsKICAgICAgdmFyIG9uQmVmb3JlRGF0YU5vZGUgPSBfYXJncy5vbkJlZm9yZURhdGFOb2RlIHx8IG51bGw7CiAgICAgIHZhciBvbkRhdGFOb2RlID0gX2FyZ3Mub25EYXRhTm9kZSB8fCBudWxsOwogICAgICB2YXIgb25EYXRhV3JhcCA9IF9hcmdzLm9uRGF0YVdyYXAgfHwgbnVsbDsKCiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsZW47IGkrKykgewogICAgICAgIG5vZGUgPSBjaGlsZHJlbltpXTsKCiAgICAgICAgaWYgKG5vZGUpIHsKICAgICAgICAgIGlmIChvbkJlZm9yZURhdGFOb2RlKSB7CiAgICAgICAgICAgIG9uQmVmb3JlRGF0YU5vZGUobm9kZSwgX2FyZ3MyKTsKICAgICAgICAgIH0KCiAgICAgICAgICBpZiAobm9kZS5fYyAmJiBub2RlLl9jLmxlbmd0aCA+IDAgJiYgIV9hcmdzLmp1c3RDaGlsZHJlbikgewogICAgICAgICAgICBpZiAob25EYXRhV3JhcCAmJiAhb25EYXRhV3JhcChub2RlLCBfYXJnczIpKSB7CiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlOwogICAgICAgICAgICB9CgogICAgICAgICAgICBpZiAoIXRoaXMuX3dhbGtOb3JtYWwobm9kZSwgX2FyZ3MsIF9hcmdzMikpIHsKICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0gZWxzZSBpZiAob25EYXRhTm9kZSAmJiAhb25EYXRhTm9kZShub2RlLCBfYXJnczIpKSB7CiAgICAgICAgICAgIHJldHVybiBmYWxzZTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH0KCiAgICAgIHJldHVybiB0cnVlOwogICAgfQogICAgLyoqCiAgICAgKiBXYWxrcyB0cmVlIGZyb20gbGVhZiB1cHdhcmRzIGFuZCBjb2xsZWN0cyBvdXRwdXRzIG9uIHRoZSB3YXkuCiAgICAgKgogICAgICogQHBhcmFtIHtvYmplY3R9IF9ub2RlCiAgICAgKiBAcGFyYW0ge29iamVjdH0gX2FyZ3MKICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW19ub1dyYXBdCiAgICAgKiBAcGFyYW0ge29iamVjdH0gW19hcmdzMl0KICAgICAqIEByZXR1cm4ge3N0cmluZ30KICAgICAqIEBhcGkgcHJpdmF0ZQogICAgICovCgogIH0sIHsKICAgIGtleTogIl93YWxrUmVuZGVyIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBfd2Fsa1JlbmRlcihfbm9kZSwgX2FyZ3MsIF9ub1dyYXAsIF9hcmdzMikgewogICAgICB2YXIgY2hpbGRyZW4gPSBfbm9kZSAmJiBfbm9kZS5fYyA/IF9ub2RlLl9jIDogW107CiAgICAgIHZhciBub2RlID0gbnVsbDsKICAgICAgdmFyIHMgPSAnJzsKICAgICAgdmFyIHMyID0gJyc7CiAgICAgIHZhciBvbkJlZm9yZURhdGFOb2RlID0gX2FyZ3Mub25CZWZvcmVEYXRhTm9kZSB8fCBudWxsOwogICAgICB2YXIgb25EYXRhTm9kZSA9IF9hcmdzLm9uRGF0YU5vZGUgfHwgbnVsbDsKCiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsZW47IGkrKykgewogICAgICAgIG5vZGUgPSBjaGlsZHJlbltpXTsKICAgICAgICBzMiA9ICcnOwoKICAgICAgICBpZiAobm9kZSkgewogICAgICAgICAgaWYgKG9uQmVmb3JlRGF0YU5vZGUpIHsKICAgICAgICAgICAgb25CZWZvcmVEYXRhTm9kZShub2RlLCBfYXJnczIpOwogICAgICAgICAgfQoKICAgICAgICAgIGlmIChub2RlLl9jICYmIG5vZGUuX2MubGVuZ3RoID4gMCAmJiAhX2FyZ3MuanVzdENoaWxkcmVuKSB7CiAgICAgICAgICAgIHMyID0gdGhpcy5fd2Fsa1JlbmRlcihub2RlLCBfYXJncywgZmFsc2UsIF9hcmdzMik7CiAgICAgICAgICB9CgogICAgICAgICAgaWYgKG9uRGF0YU5vZGUpIHsKICAgICAgICAgICAgLyogTE9HKCdVVVU6ICcgKyBub2RlLmlkKSAqLwogICAgICAgICAgICBzICs9IG9uRGF0YU5vZGUobm9kZSwgczIsIF9hcmdzMik7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9CgogICAgICBpZiAoX2FyZ3Mub25EYXRhV3JhcCAmJiAhX25vV3JhcCkgewogICAgICAgIHJldHVybiBfYXJncy5vbkRhdGFXcmFwKF9ub2RlLCBzLCBfYXJnczIpOwogICAgICB9CgogICAgICByZXR1cm4gczsKICAgIH0KICAgIC8qKgogICAgICogUmVtb3ZlIG5vZGUocykgZnJvbSB0cmVlLgogICAgICoKICAgICAqIEBwYXJhbSB7b2JqZWN0fHN0cmluZ30gX25vZGUgTm9kZSBvciBwYXRoLgogICAgICogQHBhcmFtIHthcnJheX0gW19pbnRlcnZhbF0gUmVtb3ZlIG5vZGVzIGluIHRoaXMgaW50ZXJ2YWwgb2YgaW5kaWNlcyBpbnRvIGNoaWxkcmVuIGFycmF5LiBgX25vZGVgIGlzIHBhcmVudCBpbiB0aGlzIGNhc2UuCiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtfaXNJZF0KICAgICAqIEByZXR1cm4ge2Jvb2xlYW59CiAgICAgKi8KCiAgfSwgewogICAga2V5OiAicmVtb3ZlIiwKICAgIHZhbHVlOiBmdW5jdGlvbiByZW1vdmUoX25vZGUsIF9pbnRlcnZhbCwgX2lzSWQpIHsKICAgICAgdmFyIG5vZGUgPSB0aGlzLl9nZXROb2RlKF9ub2RlLCBfaXNJZCk7CgogICAgICB2YXIgcGFyZW50ID0gbnVsbDsKICAgICAgdmFyIGlkeCA9IC0xOwogICAgICB2YXIgb3B0aW9ucyA9IHRoaXMuX29wdGlvbnM7CiAgICAgIHZhciBkYXRhUHJlcGFyZWQgPSBvcHRpb25zLnByZXBhcmVEYXRhOwogICAgICB2YXIgb25CZWZvcmVEYXRhTm9kZSA9IG9wdGlvbnMub25CZWZvcmVEYXRhTm9kZTsKICAgICAgdmFyIGludGVydmFsID0gbnVsbDsKICAgICAgdmFyIGlkOwoKICAgICAgaWYgKCFub2RlKSB7CiAgICAgICAgcmV0dXJuIGZhbHNlOwogICAgICB9CgogICAgICBpZiAoaXNBcnJheShfaW50ZXJ2YWwpKSB7CiAgICAgICAgaW50ZXJ2YWwgPSBfaW50ZXJ2YWw7CiAgICAgIH0gZWxzZSB7CiAgICAgICAgaWR4ID0gdGhpcy5nZXROb2RlSWR4KG5vZGUpOwogICAgICAgIGludGVydmFsID0gW2lkeCwgaWR4XTsKICAgICAgfQoKICAgICAgaWYgKF9pbnRlcnZhbCkgewogICAgICAgIHBhcmVudCA9IG5vZGU7CiAgICAgIH0gZWxzZSBpZiAoZGF0YVByZXBhcmVkKSB7CiAgICAgICAgcGFyZW50ID0gbm9kZS5fcDsKICAgICAgfQoKICAgICAgZm9yICh2YXIgaSA9IGludGVydmFsWzBdOyBpIDw9IGludGVydmFsWzFdOyBpKyspIHsKICAgICAgICBpZHggPSBpbnRlcnZhbFswXTsKICAgICAgICAvKiBpZiAocGFyZW50ICYmICFwYXJlbnQuX2MpIHsKICAgICAgICAgICAgYWxlcnQoJ1dUVCEhXG4nICsgdGhpcy5fdXRpbHMucHJpbnRPYmplY3RTaW1wbGUocGFyZW50LCB0cnVlKSArICdcbicgKyB0aGlzLl9vYmplY3RJZCArICdcblxuJyArIHRoaXMuX3V0aWxzLnByaW50T2JqZWN0U2ltcGxlKF9ub2RlLCB0cnVlKSArICcgLi4uICcgKyBfaW50ZXJ2YWwpOwogICAgICAgIH0gKi8KCiAgICAgICAgbm9kZSA9IHBhcmVudCA/IHBhcmVudC5fY1tpZHhdIDogdGhpcy5yb290OwoKICAgICAgICBpZiAoZGF0YVByZXBhcmVkKSB7CiAgICAgICAgICAvLyBkZWxldGUgcmVmZXJlbmNlIGZyb20gdGhpcy5kYXRhTCBvYmplY3QKICAgICAgICAgIGlkID0gdGhpcy5nZXROb2RlSWQobm9kZSk7CgogICAgICAgICAgaWYgKGlkKSB7CiAgICAgICAgICAgIGlmIChvcHRpb25zLm9uQmVmb3JlRGF0YU5vZGVSZW1vdmUpIHsKICAgICAgICAgICAgICBvcHRpb25zLm9uQmVmb3JlRGF0YU5vZGVSZW1vdmUobm9kZSk7CiAgICAgICAgICAgIH0gLy8gdGhpcy5kYXRhTFtpZF0gPSBudWxsOwoKCiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmRhdGFMW2lkXTsKICAgICAgICAgIH0gLy8gZGVsZXRlIHJlZmVyZW5jZSBmcm9tIHBhcmVudCdzIGNoaWxkcmVuIGFycmF5CiAgICAgICAgICAvLyBwYXJlbnQgPSBub2RlLl9wOwoKCiAgICAgICAgICBpZiAocGFyZW50KSB7CiAgICAgICAgICAgIHBhcmVudC5fY1tpZHhdID0gbnVsbDsKCiAgICAgICAgICAgIHBhcmVudC5fYy5zcGxpY2UoaWR4LCAxKTsKCiAgICAgICAgICAgIGlmIChwYXJlbnQuX2MubGVuZ3RoID09PSAwKSB7CiAgICAgICAgICAgICAgZGVsZXRlIHBhcmVudC5fYzsKICAgICAgICAgICAgfQogICAgICAgICAgICAvKiBpZHggPSB0aGlzLmdldE5vZGVJZHgobm9kZSk7CiAgICAgICAgICAgIGlmIChpZHggPiAtMSkgewogICAgICAgICAgICAgICAgcGFyZW50Ll9jW2lkeF0gPSBudWxsOwogICAgICAgICAgICAgICAgcGFyZW50Ll9jLnNwbGljZShpZHgsIDEpOwogICAgICAgICAgICB9ICovCgogICAgICAgICAgfQogICAgICAgIH0KCiAgICAgICAgaWYgKG9uQmVmb3JlRGF0YU5vZGUpIHsKICAgICAgICAgIG9uQmVmb3JlRGF0YU5vZGUobm9kZSk7CiAgICAgICAgfSAvLyBwcmV2ZW50IG1lbW9yeSBsZWFrcyAtIHdhbGsgYWxsIG5vZGVzIGFuZCAibnVsbCIgZGF0YQoKCiAgICAgICAgdGhpcy53YWxrKG5vZGUsIHRoaXMucmVtb3ZlV2Fsa09wdGlvbnMpOwoKICAgICAgICBpZiAobm9kZS5fcCA9PT0gbnVsbCkgewogICAgICAgICAgLy8gcm9vdAogICAgICAgICAgaWYgKGRhdGFQcmVwYXJlZCAmJiB0aGlzLmRhdGFMLl9yb290KSB7CiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmRhdGFMLl9yb290OwogICAgICAgICAgfQoKICAgICAgICAgIG5vZGUuX2MgPSBudWxsOwogICAgICAgIH0KCiAgICAgICAgbm9kZSA9IG51bGw7CiAgICAgIH0KCiAgICAgIHJldHVybiB0cnVlOwogICAgfQogICAgLyoqCiAgICAgKiBDbGVhciB0cmVlLgogICAgICoKICAgICAqIEByZXR1cm4ge3ZvaWR9CiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiY2xlYXIiLAogICAgdmFsdWU6IGZ1bmN0aW9uIGNsZWFyKCkgewogICAgICB0aGlzLnJlbW92ZSh0aGlzLnJvb3QpOwogICAgICB0aGlzLnJvb3QuX2MgPSBbXTsKICAgICAgdGhpcy5fY3Vyc29yID0gdGhpcy5yb290OwogICAgfQogICAgLyoqCiAgICAgKiBHZXQgbm9kZS4KICAgICAqCiAgICAgKiBAcGFyYW0ge29iamVjdHxzdHJpbmd9IF9ub2RlT3JQYXRoT3JJZAogICAgICogQHBhcmFtIHtib29sZWFufSBbX2lzSWRdIGBfbm9kZU9yUGF0aE9ySWRgIGlzIG5vZGUncyBpZC4KICAgICAqIEByZXR1cm4ge29iamVjdHxudWxsfSBUcmVlIG5vZGUuCiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiX2dldE5vZGUiLAogICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXROb2RlKF9ub2RlT3JQYXRoT3JJZCwgX2lzSWQpIHsKICAgICAgdmFyIG5vZGUgPSBfbm9kZU9yUGF0aE9ySWQ7CgogICAgICBpZiAodHlwZW9mIF9ub2RlT3JQYXRoT3JJZCA9PT0gJ3N0cmluZycpIHsKICAgICAgICBpZiAoX2lzSWQpIHsKICAgICAgICAgIG5vZGUgPSB0aGlzLmdldChfbm9kZU9yUGF0aE9ySWQpOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICBub2RlID0gdGhpcy5nZXROb2RlQnlQYXRoKF9ub2RlT3JQYXRoT3JJZCk7CiAgICAgICAgfQogICAgICB9CgogICAgICByZXR1cm4gbm9kZTsKICAgIH0KICAgIC8qKgogICAgICogR2V0IG5vZGUgYnkgcGF0aC4KICAgICAqCiAgICAgKiBAcGFyYW0ge3N0cmluZ30gX3BhdGgKICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW19wYXRoQ29kZV0KICAgICAqIEByZXR1cm4ge29iamVjdHxudWxsfSBUcmVlIG5vZGUuCiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiZ2V0Tm9kZUJ5UGF0aCIsCiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Tm9kZUJ5UGF0aChfcGF0aCwgX3BhdGhDb2RlKSB7CiAgICAgIHZhciBwYXRoID0gX3BhdGgudHJpbSgpOwoKICAgICAgdmFyIHBhdGhBID0gbnVsbDsKICAgICAgdmFyIGFyID0gbnVsbDsKICAgICAgdmFyIG5vZGUgPSBudWxsOwogICAgICB2YXIgcmVsYXRpdmVQYXRoID0gZmFsc2U7CiAgICAgIHZhciBwYXRoQ29kZSA9IF9wYXRoQ29kZSB8fCB0aGlzLl9vcHRpb25zLnBhdGhDb2RlOwogICAgICB2YXIgY2hpbGRyZW4gPSBudWxsOwogICAgICB2YXIgaWR4ID0gMDsKICAgICAgdmFyIGZvdW5kID0gZmFsc2U7CiAgICAgIHZhciBxdWl0ID0gZmFsc2U7CgogICAgICBpZiAocGF0aCkgewogICAgICAgIGlmIChwYXRoID09PSAnLycpIHsKICAgICAgICAgIG5vZGUgPSB0aGlzLnJvb3Q7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIHBhdGhBID0gcGF0aC5zcGxpdCgnLycpOwoKICAgICAgICAgIGlmICghcGF0aEFbMF0pIHsKICAgICAgICAgICAgLy8gYWJzb2x1dGUgcGF0aAogICAgICAgICAgICBwYXRoQS5zaGlmdCgpOwogICAgICAgICAgICBub2RlID0gdGhpcy5yb290OwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgLy8gcmVsYXRpdmUgcGF0aAogICAgICAgICAgICByZWxhdGl2ZVBhdGggPSB0cnVlOwogICAgICAgICAgICBub2RlID0gdGhpcy5fY3Vyc29yOwogICAgICAgICAgfQoKICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBwYXRoQS5sZW5ndGg7IGkgPCBsZW47IGkrKykgewogICAgICAgICAgICBwYXRoID0gcGF0aEFbaV07CgogICAgICAgICAgICBpZiAocmVsYXRpdmVQYXRoICYmIHBhdGggPT09ICcuLicpIHsKICAgICAgICAgICAgICBpZiAodGhpcy5fY3Vyc29yLl9wICE9PSBudWxsKSB7CiAgICAgICAgICAgICAgICB0aGlzLl9jdXJzb3IgPSB0aGlzLl9jdXJzb3IuX3A7CiAgICAgICAgICAgICAgICBub2RlID0gdGhpcy5fY3Vyc29yOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICBhciA9IHBhdGguc3BsaXQoJzonKTsKICAgICAgICAgICAgICBjaGlsZHJlbiA9IG5vZGUuX2M7CgogICAgICAgICAgICAgIGlmIChjaGlsZHJlbiAmJiBjaGlsZHJlbi5sZW5ndGggPiAwKSB7CiAgICAgICAgICAgICAgICBpZHggPSBwYXJzZUludChhclswXSk7CgogICAgICAgICAgICAgICAgaWYgKCFpc05hTihpZHgpKSB7CiAgICAgICAgICAgICAgICAgIG5vZGUgPSBjaGlsZHJlbltpZHhdOwogICAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgZm91bmQgPSBmYWxzZTsKCiAgICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwLCBsZW4yID0gY2hpbGRyZW4ubGVuZ3RoOyBqIDwgbGVuMjsgaisrKSB7CiAgICAgICAgICAgICAgICAgICAgaWYgKGNoaWxkcmVuW2pdW3BhdGhDb2RlXSA9PT0gYXJbMF0pIHsKICAgICAgICAgICAgICAgICAgICAgIG5vZGUgPSBjaGlsZHJlbltqXTsKICAgICAgICAgICAgICAgICAgICAgIGZvdW5kID0gdHJ1ZTsKICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgfQoKICAgICAgICAgICAgICAgICAgaWYgKCFmb3VuZCkgewogICAgICAgICAgICAgICAgICAgIG5vZGUgPSBudWxsOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICB9CgogICAgICAgICAgICAgICAgaWYgKG5vZGUpIHsKICAgICAgICAgICAgICAgICAgaWYgKGFyLmxlbmd0aCA9PT0gMiAmJiBub2RlW3BhdGhDb2RlXSAhPT0gYXJbMV0pIHsKICAgICAgICAgICAgICAgICAgICBxdWl0ID0gdHJ1ZTsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgcXVpdCA9IHRydWU7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgIHF1aXQgPSB0cnVlOwogICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgaWYgKHF1aXQpIHsKICAgICAgICAgICAgICAgIG5vZGUgPSBudWxsOwogICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9CgogICAgICByZXR1cm4gbm9kZTsKICAgIH0KICAgIC8qKgogICAgICogR2V0IHBhdGggKGFic29sdXRlKSBvZiBub2RlLgogICAgICoKICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbX25vZGVdIERhdGEgbm9kZS4KICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW193aXRoUGF0aENvZGVdIEdldCBwYXRoIHdpdGggcGF0aCBjb2RlIChgX3R5cGVgKS4KICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbX3BhdGhDb2RlXSBQYXRoIHdpdGhvdXQgaW5kZXggYW5kIHdpdGggX3BhdGhDb2RlLgogICAgICogQHJldHVybiB7c3RyaW5nfQogICAgICovCgogIH0sIHsKICAgIGtleTogImdldFBhdGgiLAogICAgdmFsdWU6IGZ1bmN0aW9uIGdldFBhdGgoX25vZGUsIF93aXRoUGF0aENvZGUsIF9wYXRoQ29kZSkgewogICAgICB2YXIgbm9kZSA9IF9ub2RlIHx8IHRoaXMucm9vdDsKICAgICAgdmFyIHBhdGhDb2RlID0gdGhpcy5fb3B0aW9ucy5wYXRoQ29kZTsKICAgICAgdmFyIGFQYXRoID0gWycnXTsKICAgICAgdmFyIHBhcmVudHMgPSBudWxsOwogICAgICB2YXIgcGF0aCA9ICcnOwoKICAgICAgaWYgKG5vZGUgPT09IHRoaXMucm9vdCkgewogICAgICAgIHBhdGggPSAnLyc7CiAgICAgIH0gZWxzZSB7CiAgICAgICAgcGFyZW50cyA9IHRoaXMuZ2V0UGFyZW50cyhub2RlKTsKCiAgICAgICAgaWYgKHBhcmVudHMubGVuZ3RoID4gMCkgewogICAgICAgICAgZm9yICh2YXIgaSA9IHBhcmVudHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHsKICAgICAgICAgICAgaWYgKF9wYXRoQ29kZSkgewogICAgICAgICAgICAgIGFQYXRoLnB1c2gocGFyZW50c1tpXVtfcGF0aENvZGVdKTsKICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICBhUGF0aC5wdXNoKHRoaXMuZ2V0Tm9kZUlkeChwYXJlbnRzW2ldKSArIChfd2l0aFBhdGhDb2RlID8gIjoiLmNvbmNhdChwYXJlbnRzW2ldW3BhdGhDb2RlXSkgOiAnJykpOwogICAgICAgICAgICB9CiAgICAgICAgICB9CgogICAgICAgICAgcGF0aCA9IGFQYXRoLmpvaW4oJy8nKTsKICAgICAgICB9CiAgICAgIH0KCiAgICAgIHJldHVybiBwYXRoOwogICAgfQogICAgLyoqCiAgICAgKiBTZXQgY3Vyc29yIHRvIG5vZGUgZGVmaW5lZCBieSBwYXRoIG9yIG5vZGUuCiAgICAgKgogICAgICogQHBhcmFtIHtvYmplY3R8c3RyaW5nfSBfbm9kZU9yUGF0aAogICAgICogQHJldHVybiB7b2JqZWN0fG51bGx9IEN1cnNvciBvciBudWxsLgogICAgICovCgogIH0sIHsKICAgIGtleTogImNkIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBjZChfbm9kZU9yUGF0aCkgewogICAgICB2YXIgbm9kZSA9IHRoaXMuX2dldE5vZGUoX25vZGVPclBhdGgpOwoKICAgICAgaWYgKG5vZGUpIHsKICAgICAgICB0aGlzLl9jdXJzb3IgPSBub2RlOwogICAgICB9CgogICAgICByZXR1cm4gbm9kZTsKICAgIH0KICAgIC8qKgogICAgICogR2V0IGFycmF5IG9mIG5vZGUncyBwYXJlbnRzIChpbmNsdWRpbmcgbm9kZSBpdHNlbGYpLgogICAgICoKICAgICAqIEBwYXJhbSB7Kn0gX2lkT3JOb2RlCiAgICAgKiBAcGFyYW0geyp9IFtfZW5kUGFyZW50Tm9kZV0gSWQgb3Igbm9kZS4KICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW19nZXRPYmplY3RJZHNdCiAgICAgKiBAcmV0dXJuIHthcnJheX0gQXJyYXkgb2Ygbm9kZXMuCiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiZ2V0UGFyZW50cyIsCiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0UGFyZW50cyhfaWRPck5vZGUsIF9lbmRQYXJlbnROb2RlLCBfZ2V0T2JqZWN0SWRzKSB7CiAgICAgIHZhciBub2RlID0gdGhpcy5fZ2V0Tm9kZShfaWRPck5vZGUsIHRydWUpOwoKICAgICAgdmFyIGVuZFBhcmVudE5vZGUgPSBfZW5kUGFyZW50Tm9kZSA/IHRoaXMuX2dldE5vZGUoX2VuZFBhcmVudE5vZGUsIHRydWUpIDogbnVsbDsKICAgICAgdmFyIHBhcmVudHMgPSBbXTsKCiAgICAgIGlmIChub2RlKSB7CiAgICAgICAgcGFyZW50cy5wdXNoKF9nZXRPYmplY3RJZHMgPyBub2RlLl9jb21wb25lbnRJZCA6IG5vZGUpOwogICAgICAgIG5vZGUgPSBub2RlLl9wOwoKICAgICAgICB3aGlsZSAobm9kZSAmJiBub2RlLl9wICE9PSBlbmRQYXJlbnROb2RlKSB7CiAgICAgICAgICBwYXJlbnRzLnB1c2goX2dldE9iamVjdElkcyA/IG5vZGUuX2NvbXBvbmVudElkIDogbm9kZSk7CiAgICAgICAgICBub2RlID0gbm9kZS5fcDsKICAgICAgICB9CiAgICAgIH0KCiAgICAgIHJldHVybiBwYXJlbnRzOwogICAgfQogICAgLyoqCiAgICAgKiBHZXQgYXJyYXkgb2Ygbm9kZSdzIHBhcmVudHMgYnkgYW4gYXR0cmlidWUgKG5vZGUgaXMgbm90IGluY2x1ZGVkKS4KICAgICAqCiAgICAgKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ8YXJyYXl9IF92YWwgVmFsdWUgb3IgYXJyYXkgb2YgdmFsdWVzLgogICAgICogQHBhcmFtIHtpbnR8c3RyaW5nfSBfa2V5IElmIGRhdGEgaXRlbSBpcyBhcnJheSB0aGVuIF9rZXkgaXMgaW5kZXggaW50byB0aGF0IGFycmF5LCBvdGhlcndpc2UgaXQncyBrZXkgb2YgYW4gb2JqZWN0LgogICAgICogQHBhcmFtIHsqfSBfaWRPck5vZGUKICAgICAqIEBwYXJhbSB7Kn0gW19lbmRQYXJlbnROb2RlXSBJZCBvciBub2RlLgogICAgICogQHBhcmFtIHtib29sZWFufSBbX2dldE9iamVjdElkc10KICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW19nZXRGaXJzdFBhcmVudF0gR2V0IGp1c3QgZmlyc3QgcGFyZW50J3MgbWF0Y2guCiAgICAgKiBAcmV0dXJuIHthcnJheXxvYmplY3R8bnVsbH0gQXJyYXkgb2Ygbm9kZXMuCiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiZ2V0UGFyZW50c0J5IiwKICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRQYXJlbnRzQnkoX3ZhbCwgX2tleSwgX2lkT3JOb2RlLCBfZW5kUGFyZW50Tm9kZSwgX2dldE9iamVjdElkcywgX2dldEZpcnN0UGFyZW50KSB7CiAgICAgIHZhciBub2RlID0gdGhpcy5fZ2V0Tm9kZShfaWRPck5vZGUsIHRydWUpOwoKICAgICAgdmFyIGVuZFBhcmVudE5vZGUgPSBfZW5kUGFyZW50Tm9kZSA/IHRoaXMuX2dldE5vZGUoX2VuZFBhcmVudE5vZGUsIHRydWUpIDogbnVsbDsKICAgICAgdmFyIHBhcmVudHMgPSBbXTsKICAgICAgdmFyIHZhbHMgPSBpc0FycmF5KF92YWwpID8gX3ZhbCA6IFtfdmFsXTsKCiAgICAgIGlmIChub2RlKSB7CiAgICAgICAgbm9kZSA9IG5vZGUuX3A7CgogICAgICAgIHdoaWxlIChub2RlICYmIG5vZGUuX3AgIT09IGVuZFBhcmVudE5vZGUpIHsKICAgICAgICAgIGlmIChpbkFycmF5KG5vZGVbX2tleV0sIHZhbHMpID4gLTEpIHsKICAgICAgICAgICAgcGFyZW50cy5wdXNoKF9nZXRPYmplY3RJZHMgPyBub2RlLl9jb21wb25lbnRJZCA6IG5vZGUpOwoKICAgICAgICAgICAgaWYgKF9nZXRGaXJzdFBhcmVudCkgewogICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICB9CiAgICAgICAgICB9CgogICAgICAgICAgbm9kZSA9IG5vZGUuX3A7CiAgICAgICAgfQogICAgICB9CgogICAgICBpZiAoIV9nZXRGaXJzdFBhcmVudCkgewogICAgICAgIHJldHVybiBwYXJlbnRzOwogICAgICB9CgogICAgICBpZiAocGFyZW50cy5sZW5ndGggPiAwKSB7CiAgICAgICAgcmV0dXJuIHBhcmVudHNbMF07CiAgICAgIH0KCiAgICAgIHJldHVybiBudWxsOwogICAgfQogICAgLyoqCiAgICAgKiBHZXQgY2hpbGQgb2Ygbm9kZSBieSBpbmRleC4KICAgICAqCiAgICAgKiBAcGFyYW0ge29iamVjdH0gX25vZGUKICAgICAqIEBwYXJhbSB7aW50fSBfaWR4CiAgICAgKiBAcmV0dXJuIHtvYmplY3R8bnVsbH0gTm9kZS4KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJnZXRDaGlsZEJ5SWR4IiwKICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRDaGlsZEJ5SWR4KF9ub2RlLCBfaWR4KSB7CiAgICAgIHZhciBjaGlsZE5vZGUgPSBudWxsOwogICAgICB2YXIgY2hpbGRyZW4gPSBudWxsOwoKICAgICAgaWYgKF9ub2RlICYmIF9pZHggPj0gMCkgewogICAgICAgIGNoaWxkcmVuID0gX25vZGUuX2M7CgogICAgICAgIGlmIChjaGlsZHJlbiAmJiBjaGlsZHJlbi5sZW5ndGggPiAwICYmIGNoaWxkcmVuW19pZHhdICE9PSB1bmRlZmluZWQpIHsKICAgICAgICAgIGNoaWxkTm9kZSA9IGNoaWxkcmVuW19pZHhdOwogICAgICAgIH0KICAgICAgfQoKICAgICAgcmV0dXJuIGNoaWxkTm9kZTsKICAgIH0KICAgIC8qKgogICAgICogQHBhcmFtIHtvYmplY3R9IF9ub2RlCiAgICAgKiBAcmV0dXJuIHtvYmplY3R8bnVsbH0gTm9kZS4KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJnZXRQcmV2Tm9kZSIsCiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0UHJldk5vZGUoX25vZGUpIHsKICAgICAgcmV0dXJuIHRoaXMuX2dldFByZXZPck5leHROb2RlKF9ub2RlKTsKICAgIH0KICAgIC8qKgogICAgICogQHBhcmFtIHtvYmplY3R9IF9ub2RlCiAgICAgKiBAcmV0dXJuIHtvYmplY3R8bnVsbH0gTm9kZS4KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJnZXROZXh0Tm9kZSIsCiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0TmV4dE5vZGUoX25vZGUpIHsKICAgICAgcmV0dXJuIHRoaXMuX2dldFByZXZPck5leHROb2RlKF9ub2RlLCB0cnVlKTsKICAgIH0KICAgIC8qKgogICAgICogQHBhcmFtIHtvYmplY3R9IF9ub2RlCiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtfbmV4dF0KICAgICAqIEByZXR1cm4ge29iamVjdHxudWxsfSBOb2RlLgogICAgICovCgogIH0sIHsKICAgIGtleTogIl9nZXRQcmV2T3JOZXh0Tm9kZSIsCiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldFByZXZPck5leHROb2RlKF9ub2RlLCBfbmV4dCkgewogICAgICB2YXIgbm9kZSA9IG51bGw7CiAgICAgIHZhciBpZHggPSAtMTsKICAgICAgdmFyIGNoaWxkcmVuID0gbnVsbDsKCiAgICAgIGlmIChfbm9kZSkgewogICAgICAgIGlkeCA9IHRoaXMuZ2V0Tm9kZUlkeChfbm9kZSk7CgogICAgICAgIGlmIChpZHggPiAtMSkgewogICAgICAgICAgY2hpbGRyZW4gPSBfbm9kZS5fcC5fYzsKCiAgICAgICAgICBpZiAoY2hpbGRyZW4pIHsKICAgICAgICAgICAgaWYgKF9uZXh0KSB7CiAgICAgICAgICAgICAgaWYgKGlkeCArIDEgPD0gY2hpbGRyZW4ubGVuZ3RoIC0gMSkgewogICAgICAgICAgICAgICAgbm9kZSA9IGNoaWxkcmVuW2lkeCArIDFdOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfSBlbHNlIGlmIChpZHggLSAxID49IDApIHsKICAgICAgICAgICAgICBub2RlID0gY2hpbGRyZW5baWR4IC0gMV07CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH0KCiAgICAgIHJldHVybiBub2RlOwogICAgfQogICAgLyoqCiAgICAgKiBHZXQgY2hpbGQgb2Ygbm9kZSBieSBpbmRleC4KICAgICAqCiAgICAgKiBAcGFyYW0geyp9IF9pZE9yTm9kZQogICAgICogQHJldHVybiB7QXJyYXl9CiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiZ2V0U2libGluZ3MiLAogICAgdmFsdWU6IGZ1bmN0aW9uIGdldFNpYmxpbmdzKF9pZE9yTm9kZSkgewogICAgICB2YXIgbm9kZSA9IHRoaXMuX2dldE5vZGUoX2lkT3JOb2RlLCB0cnVlKTsKCiAgICAgIHZhciBzaWJsaW5ncyA9IFtdOwogICAgICB2YXIgY2hpbGRyZW47CgogICAgICBpZiAobm9kZS5fcCkgewogICAgICAgIGNoaWxkcmVuID0gbm9kZS5fcC5fYzsKCiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbjEgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsZW4xOyBpKyspIHsKICAgICAgICAgIGlmIChjaGlsZHJlbltpXSAhPT0gbm9kZSkgewogICAgICAgICAgICBzaWJsaW5ncy5wdXNoKGNoaWxkcmVuW2ldKTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH0KCiAgICAgIHJldHVybiBzaWJsaW5nczsKICAgIH0KICAgIC8qKgogICAgICogR2V0IG5vZGUgYnkgaWQuCiAgICAgKgogICAgICogQHBhcmFtIHtpbnR8c3RyaW5nfSBfaWQgSWQgb2Ygbm9kZSAoaW5kZXggMCBvciAuaWQgcHJvcGVydHkpLgogICAgICogQHJldHVybiB7b2JqZWN0fG51bGx9IE5vZGUuCiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiZ2V0IiwKICAgIHZhbHVlOiBmdW5jdGlvbiBnZXQoX2lkKSB7CiAgICAgIHJldHVybiB0aGlzLmRhdGFMW19pZF0gfHwgbnVsbDsKICAgIH0KICAgIC8qKgogICAgICogR2V0IG5vZGUocykgYnkgdmFsdWUgYW5kIGtleS4KICAgICAqCiAgICAgKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IF92YWwKICAgICAqIEBwYXJhbSB7aW50fHN0cmluZ30gX2tleSBJZiBkYXRhIGl0ZW0gaXMgYXJyYXkgdGhlbiBfa2V5IGlzIGluZGV4IGludG8gdGhhdCBhcnJheSwgb3RoZXJ3aXNlIGl0J3Mga2V5IG9mIGFuIG9iamVjdC4KICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW19maW5kQWxsXSBJZiB0cnVlLCBmaW5kIGFsbCBwb3NzaWJsZSBvY2N1cnJlbmNlcywgb3RoZXJ3aXNlIGZpbmQgb25seSB0aGUgZmlyc3Qgb25lLgogICAgICogQHJldHVybiB7Kn0gSXRlbSAob3IgbnVsbCkgb3IgYXJyYXkgb2YgaXRlbXMuCiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiZ2V0QnkiLAogICAgdmFsdWU6IGZ1bmN0aW9uIGdldEJ5KF92YWwsIF9rZXksIF9maW5kQWxsKSB7CiAgICAgIHZhciBkYXRhID0gdGhpcy5kYXRhTDsKICAgICAgdmFyIG5vZGUgPSBfZmluZEFsbCA/IFtdIDogbnVsbDsKICAgICAgdmFyIG4gPSBudWxsOyAvLyBnZXQgYnkgaWQKCiAgICAgIGlmIChfa2V5ID09PSAnaWQnKSB7CiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0KF92YWwpOwogICAgICB9CgogICAgICBmb3IgKHZhciBpIGluIGRhdGEpIHsKICAgICAgICBuID0gZGF0YVtpXTsKCiAgICAgICAgaWYgKG5bX2tleV0gPT0gX3ZhbCkgewogICAgICAgICAgaWYgKF9maW5kQWxsKSB7CiAgICAgICAgICAgIG5vZGUucHVzaChkYXRhW2ldKTsKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIG5vZGUgPSBkYXRhW2ldOwogICAgICAgICAgICBicmVhazsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH0KCiAgICAgIHJldHVybiBub2RlOwogICAgfQogICAgLyoqCiAgICAgKiBHZXQgbm9kZShzKSBieSB2YWx1ZSBhbmQga2V5LCBzZWFyY2ggbm9kZXMgcmVjdXJzaXZlbHkuCiAgICAgKiBJZiBgX3N0YXJ0Tm9kZWAgaXMgc3BlY2lmaWVkLCBzdGFydCBzZWFyY2hpbmcgZnJvbSB0aGlzIG5vZGUsIGl0IHdvbid0IGJlCiAgICAgKiBpbmNsdWRlZCBpbiBzZWFyY2ggcmVzdWx0LgogICAgICoKICAgICAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gX3ZhbAogICAgICogQHBhcmFtIHtpbnR8c3RyaW5nfSBfa2V5IElmIGRhdGEgaXRlbSBpcyBhcnJheSB0aGVuIF9rZXkgaXMgaW5kZXggaW50byB0aGF0IGFycmF5LCBvdGhlcndpc2UgaXQncyBrZXkgb2YgYW4gb2JqZWN0LgogICAgICogQHBhcmFtIHtvYmplY3R8c3RyaW5nfSBbX3N0YXJ0Tm9kZV0gU3RhcnQgbm9kZSBvciBwYXRoLgogICAgICogQHBhcmFtIHtib29sZWFufSBbX2ZpbmRBbGxdIElmIHRydWUsIGZpbmQgYWxsIHBvc3NpYmxlIG9jY3VycmVuY2VzLCBvdGhlcndpc2UgZmluZCBvbmx5IHRoZSBmaXJzdCBvbmUuCiAgICAgKiBAcmV0dXJuIHsqfSBJdGVtIG9yIGFycmF5IG9mIGl0ZW1zLgogICAgICovCgogIH0sIHsKICAgIGtleTogImdldEJ5UiIsCiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0QnlSKF92YWwsIF9rZXksIF9zdGFydE5vZGUsIF9maW5kQWxsKSB7CiAgICAgIHZhciBzdGFydE5vZGUgPSB0aGlzLl9nZXROb2RlKF9zdGFydE5vZGUpIHx8IHRoaXMuX3Jvb3Q7CgogICAgICB2YXIgbm9kZXMgPSBbXTsKICAgICAgdmFyIHNlbGYgPSB0aGlzOyAvLyBnZXQgYnkgaWQKCiAgICAgIGlmIChfa2V5ID09PSAnaWQnKSB7CiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0KF92YWwpOwogICAgICB9CgogICAgICB0aGlzLndhbGsoc3RhcnROb2RlLCB7CiAgICAgICAgLy8gd2Fsa1R5cGU6ICdyZW5kZXInLAogICAgICAgIG9uRGF0YVdyYXA6IGZ1bmN0aW9uIG9uRGF0YVdyYXAoX25vZGUpIHsKICAgICAgICAgIHJldHVybiBzZWxmLl9nZXRCeVIoX25vZGUsIF92YWwsIF9rZXksIG5vZGVzLCBfZmluZEFsbCk7CiAgICAgICAgfSwKICAgICAgICBvbkRhdGFOb2RlOiBmdW5jdGlvbiBvbkRhdGFOb2RlKF9ub2RlKSB7CiAgICAgICAgICByZXR1cm4gc2VsZi5fZ2V0QnlSKF9ub2RlLCBfdmFsLCBfa2V5LCBub2RlcywgX2ZpbmRBbGwpOwogICAgICAgIH0KICAgICAgfSk7CgogICAgICBmb3IgKHZhciBpID0gMCwgbGVuMSA9IG5vZGVzLmxlbmd0aDsgaSA8IGxlbjE7IGkrKykgewogICAgICAgIGRlbGV0ZSBub2Rlc1tpXS5fX2ZvdW5kOwogICAgICB9CgogICAgICBpZiAoX2ZpbmRBbGwpIHsKICAgICAgICByZXR1cm4gbm9kZXM7CiAgICAgIH0KCiAgICAgIGlmIChub2Rlcy5sZW5ndGggPiAwKSB7CiAgICAgICAgcmV0dXJuIG5vZGVzWzBdOwogICAgICB9CgogICAgICByZXR1cm4gbnVsbDsKICAgIH0KICAgIC8qKgogICAgICogUHJpdmF0ZSBmdW5jdGlvbiBmb3IgdHJlZSB3YWxraW5nIGluIGBnZXRCeVJgIG1ldGhvZC4KICAgICAqCiAgICAgKiBAcGFyYW0ge29iamVjdH0gX25vZGUgVHJlZSBub2RlLgogICAgICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSBfdmFsCiAgICAgKiBAcGFyYW0ge2ludHxzdHJpbmd9IF9rZXkgSWYgZGF0YSBpdGVtIGlzIGFycmF5IHRoZW4gX2tleSBpcyBpbmRleCBpbnRvIHRoYXQgYXJyYXksIG90aGVyd2lzZSBpdCdzIGtleSBvZiBhbiBvYmplY3QuCiAgICAgKiBAcGFyYW0ge2FycmF5fSBfcmVzdWx0CiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtfZmluZEFsbF0gSWYgdHJ1ZSwgZmluZCBhbGwgcG9zc2libGUgb2NjdXJyZW5jZXMsIG90aGVyd2lzZSBmaW5kIG9ubHkgdGhlIGZpcnN0IG9uZS4KICAgICAqIEByZXR1cm4ge2Jvb2xlYW59CiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiX2dldEJ5UiIsCiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldEJ5Uihfbm9kZSwgX3ZhbCwgX2tleSwgX3Jlc3VsdCwgX2ZpbmRBbGwpIHsKICAgICAgdmFyIGZvdW5kID0gZmFsc2U7CgogICAgICBpZiAoX25vZGVbX2tleV0gPT0gX3ZhbCkgewogICAgICAgIGlmICghX25vZGUuX19mb3VuZCkgewogICAgICAgICAgX25vZGUuX19mb3VuZCA9IHRydWU7CgogICAgICAgICAgX3Jlc3VsdC5wdXNoKF9ub2RlKTsKICAgICAgICB9CgogICAgICAgIGZvdW5kID0gdHJ1ZTsKICAgICAgfQoKICAgICAgcmV0dXJuICEoIV9maW5kQWxsICYmIGZvdW5kKTsKICAgIH0KICAgIC8qKgogICAgICogRmluZCBub2RlJ3MgcG9zaXRpb24gKGluZGV4KSBpbiBgX25vZGUuX3AuX2NgIGFycmF5LgogICAgICoKICAgICAqIEBwYXJhbSB7b2JqZWN0fSBfbm9kZQogICAgICogQHJldHVybiB7aW50fSAtMSBpZiBmYWlsLgogICAgICovCgogIH0sIHsKICAgIGtleTogImdldE5vZGVJZHgiLAogICAgdmFsdWU6IGZ1bmN0aW9uIGdldE5vZGVJZHgoX25vZGUpIHsKICAgICAgdmFyIGNoaWxkcmVuID0gbnVsbDsKCiAgICAgIGlmICghX25vZGUgfHwgIV9ub2RlLl9wIHx8ICFfbm9kZS5fcC5fYykgewogICAgICAgIHJldHVybiAtMTsKICAgICAgfQoKICAgICAgY2hpbGRyZW4gPSBfbm9kZS5fcC5fYzsKCiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsZW47IGkrKykgewogICAgICAgIGlmIChjaGlsZHJlbltpXSA9PT0gX25vZGUpIHsKICAgICAgICAgIHJldHVybiBpOwogICAgICAgIH0KICAgICAgfQoKICAgICAgcmV0dXJuIC0xOwogICAgfQogICAgLyoqCiAgICAgKiBHZXQgbm9kZSdzIGlkLgogICAgICoKICAgICAqIEBwYXJhbSB7b2JqZWN0fSBfbm9kZQogICAgICogQHJldHVybiB7Kn0KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJnZXROb2RlSWQiLAogICAgdmFsdWU6IGZ1bmN0aW9uIGdldE5vZGVJZChfbm9kZSkgewogICAgICBpZiAoX25vZGUpIHsKICAgICAgICBpZiAoX25vZGUuX3AgPT09IG51bGwpIHsKICAgICAgICAgIC8vIHJvb3QKICAgICAgICAgIHJldHVybiAwOwogICAgICAgIH0KCiAgICAgICAgcmV0dXJuIF9ub2RlLmlkOwogICAgICB9CgogICAgICByZXR1cm4gMDsKICAgIH0KICB9XSk7CgogIHJldHVybiBUcmVlOwp9KCk7"},{"version":3,"names":["isArray","inArray","shortid","Tree","_data","_options","data","walkType","pathCode","prepareData","addId","_addId","checkChangesOnUpdate","onDataNode","onDataWrap","onBeforeNodeRemove","onBeforeDataNode","onBeforeDataRemove","Object","assign","options","root","_c","_p","_l","dataL","_cursor","removeWalkOptions","_node","id","getNodeId","onBeforeDataNodeRemove","setData","remove","length","clear","prepare","item","node","undefined","_getId","_prepare","generate","_level","children","preserveId","level","i","len","_parent","c","_args","_args2","args","justChildren","renderStartNode","noFristWrap","ret","normalWalkParent","_walkNormal","_walkRender","_noWrap","s","s2","_interval","_isId","_getNode","parent","idx","dataPrepared","interval","getNodeIdx","splice","walk","_root","_nodeOrPathOrId","get","getNodeByPath","_path","_pathCode","path","trim","pathA","ar","relativePath","found","quit","split","shift","parseInt","isNaN","j","len2","_withPathCode","aPath","parents","getParents","push","join","_nodeOrPath","_idOrNode","_endParentNode","_getObjectIds","endParentNode","_componentId","_val","_key","_getFirstParent","vals","_idx","childNode","_getPrevOrNextNode","_next","siblings","len1","_id","_findAll","n","_startNode","startNode","nodes","self","_getByR","__found","_result"],"sources":["/mnt/websites/ex.nextsmartchain.com/src/utils/tree.js"],"sourcesContent":["import { isArray, inArray } from \"./index.js\";\nimport shortid from 'shortid';\n\nexport class Tree {\n    constructor(_data, _options) {\n        this._options = {\n            // you can't insert or remove tree item\n            // readOnly: true,\n            // idPrefix: 'i',\n            data: null,\n            walkType: 'normal',\n            pathCode: '_type',\n            prepareData: true,\n            addId: false,\n            _addId: false,\n            checkChangesOnUpdate: false,\n            // function\n            onDataNode: null,\n            onDataWrap: null,\n            onBeforeNodeRemove: null,\n            onBeforeDataNode: null,\n            onBeforeDataRemove: null,\n        };\n\n        Object.assign(this._options, _options);\n\n        const options = this._options;\n\n        /** Root of the tree. */\n        this.root = {\n            // id: '_root',\n            _c: [], // children\n            _p: null, // parent\n            _l: -1, // level\n        };\n\n        /** Keys are ids (row.id or row[0]), values are references to `this.root` array items. */\n        this.dataL = {};\n        /** Pointer to actual node. */\n        this._cursor = this.root;\n        /** Options for remove walking. */\n        this.removeWalkOptions = {\n            walkType: 'render',\n            onDataNode: _node => {\n                let id = '';\n\n                if (options.onBeforeNodeRemove) {\n                    options.onBeforeNodeRemove(_node);\n                }\n\n                if (options.prepareData) {\n                    if (options.onBeforeDataRemove) {\n                        options.onBeforeDataRemove(_node);\n                    }\n\n                    id = this.getNodeId(_node);\n                    if (id) {\n                        delete this.dataL[id];\n                    }\n                }\n\n                if (_node._c) {\n                    _node._c = null;\n                }\n\n                return '';\n            },\n            onDataWrap() {},\n            onBeforeDataNode: options.onBeforeDataNodeRemove || null,\n        };\n\n        if (options.addId) {\n            options._addId = true;\n        }\n\n        this.setData(_data || []);\n    }\n\n    _destructor() {\n        this.remove(this.root);\n    }\n\n    /**\n     * Set new data.\n     *\n     * @param {array} _data Tree data.\n     * @return {void}\n     */\n    setData(_data) {\n        if (isArray(_data)) {\n            if (this.root._c.length > 0) {\n                this.clear(true);\n            }\n\n            this.root._c = _data;\n\n            if (this._options.prepareData) {\n                this.prepare();\n            }\n        }\n    }\n\n    /**\n     * Walk data and add level and parent informations to node and create `this.dataL` object.\n     *\n     * @param {object} [_node] Start preparing data from node `_node`.\n     * @return {void}\n     */\n    prepare(_node) {\n        let item = null;\n        const options = this._options;\n        let node = null;\n        const { dataL } = this;\n\n        if (_node) {\n            item = _node;\n\n            if (options._addId && item.id === undefined) {\n                item.id = this._getId(); // 'dn' + this._cntr++;\n                if (dataL[item.id] !== undefined) {\n                    do {\n                        item.id = this._getId(); // 'dn' + this._cntr++;\n                    } while (dataL[item.id] !== undefined);\n                }\n\n                dataL[item.id] = _node;\n            }\n        }\n\n        if (_node) {\n            node = _node;\n        } else {\n            node = this.root;\n            if (node.id === undefined && options._addId) {\n                node.id = '_root';\n                dataL[node.id] = node;\n            }\n        }\n\n        this._prepare(node);\n    }\n\n    /**\n     * Get unique id.\n     *\n     * @return {string}\n     * @private\n     */\n    _getId() {\n        return shortid.generate();\n    }\n\n    /**\n     * Walk data and add level and parent informations to node\n     * and create `this.dataL` object.\n     *\n     * @param {object} _node\n     * @param {int} [_level]\n     * @return {void}\n     * @api private\n     */\n    _prepare(_node, _level) {\n        const children = _node && _node._c ? _node._c : [];\n        const options = this._options;\n        const addId = options._addId;\n        const { preserveId } = options;\n        let node = null;\n        let item = null;\n        const level = _level === undefined && _node ? _node._l + 1 : _level;\n        let id;\n        // readOnly = this._options.readOnly,\n        // onDataNode = this.onDataNode,\n\n        for (let i = 0, len = children.length; i < len; i++) {\n            node = children[i];\n\n            if (!node) {\n                // IE8 bitch\n                continue;\n            }\n\n            item = node;\n\n            if (addId) {\n                if (!(preserveId && item.id)) {\n                    item.id = this._getId(); // 'dn' + this._cntr++;\n                } /* else {\n                    this._cntr++;\n                } */\n            }\n\n            node._p = _node;\n            node._l = level;\n\n            id = item.id;\n\n            this.dataL[id] = node;\n\n            if (node._c) {\n                this._prepare(node);\n            }\n        }\n    }\n\n    /**\n     * Prepare just one node.\n     *\n     * @param {object} _node\n     * @param {object} _parent P`arent` node.\n     * @return {void}\n     */\n    prepareNode(_node, _parent) {\n        let id;\n\n        _node._p = _parent;\n        _node._l = _parent._l + 1;\n\n        id = this.getNodeId(_node);\n        if (id) {\n            this.dataL[id] = _node;\n        }\n    }\n\n    /**\n     * Check to see, if tree is empty.\n     *\n     * @return {boolean}\n     */\n    isEmpty() {\n        const c = this.root._c;\n\n        return !(c && c.length > 0);\n    }\n\n    /**\n     * Walk tree.\n     *\n     * @param {object} [_node]\n     * @param {object} [_args]\n     * @param {object} [_args2]\n     * @return {String|Boolean}\n     */\n    walk(_node, _args, _args2) {\n        const options = this._options;\n        const args = {\n            onDataNode: null, // function\n            onDataWrap: null, // function\n            onBeforeDataNode: null,\n            justChildren: false, // Walk on children only.\n            renderStartNode: false,\n            noFristWrap: false, // don't render first wrap element\n            walkType: '', // 'normal' | 'render'\n        };\n        let node = null;\n        let ret;\n\n        Object.assign(args, _args);\n\n        if (args.onDataNode === null) {\n            args.onDataNode = options.onDataNode;\n        }\n\n        if (args.onDataWrap === null) {\n            args.onDataWrap = options.onDataWrap;\n        }\n\n        if (args.walkType === '') {\n            args.walkType = options.walkType;\n        }\n\n        switch (args.walkType) {\n            case 'normal':\n                // call `onDataWrap` function on `node`, if it is parent\n                if (options.normalWalkParent) {\n                    node = _node || this.root;\n                    if (node && node._c && node._c.length > 0) {\n                        if (args.onDataWrap) {\n                            args.onDataWrap(node, _args2);\n                        }\n                    }\n                }\n\n                ret = this._walkNormal(_node || this.root, args, _args2);\n                break;\n            case 'render':\n                if (args.renderStartNode) {\n                    _node = { _c: [_node] };\n                }\n\n                ret = this._walkRender(\n                    _node || this.root,\n                    args,\n                    args.renderStartNode || args.noFristWrap,\n                    _args2,\n                );\n                break;\n            default:\n                ret = false;\n        }\n\n        args.onDataNode = null;\n        args.onDataWrap = null;\n\n        return ret;\n    }\n\n    /**\n     * Walks tree from node `_node` downwards to the leafs.\n     * Walking can be stopped by returning `false` in the walk function.\n     *\n     * @param {object} _node\n     * @param {object} _args\n     * @param {object} [_args2]\n     * @return {string}\n     * @api private\n     */\n    _walkNormal(_node, _args, _args2) {\n        const children = _node && _node._c ? _node._c : [];\n        let node = null;\n        const onBeforeDataNode = _args.onBeforeDataNode || null;\n        const onDataNode = _args.onDataNode || null;\n        const onDataWrap = _args.onDataWrap || null;\n\n        for (let i = 0, len = children.length; i < len; i++) {\n            node = children[i];\n\n            if (node) {\n                if (onBeforeDataNode) {\n                    onBeforeDataNode(node, _args2);\n                }\n\n                if (node._c && node._c.length > 0 && !_args.justChildren) {\n                    if (onDataWrap && !onDataWrap(node, _args2)) {\n                        return false;\n                    }\n\n                    if (!this._walkNormal(node, _args, _args2)) {\n                        return false;\n                    }\n                } else if (onDataNode && !onDataNode(node, _args2)) {\n                    return false;\n                }\n            }\n        }\n\n        return true;\n    }\n\n    /**\n     * Walks tree from leaf upwards and collects outputs on the way.\n     *\n     * @param {object} _node\n     * @param {object} _args\n     * @param {boolean} [_noWrap]\n     * @param {object} [_args2]\n     * @return {string}\n     * @api private\n     */\n    _walkRender(_node, _args, _noWrap, _args2) {\n        const children = _node && _node._c ? _node._c : [];\n        let node = null;\n        let s = '';\n        let s2 = '';\n        const onBeforeDataNode = _args.onBeforeDataNode || null;\n        const onDataNode = _args.onDataNode || null;\n\n        for (let i = 0, len = children.length; i < len; i++) {\n            node = children[i];\n            s2 = '';\n\n            if (node) {\n                if (onBeforeDataNode) {\n                    onBeforeDataNode(node, _args2);\n                }\n\n                if (node._c && node._c.length > 0 && !_args.justChildren) {\n                    s2 = this._walkRender(node, _args, false, _args2);\n                }\n\n                if (onDataNode) {\n                    /* LOG('UUU: ' + node.id) */\n                    s += onDataNode(node, s2, _args2);\n                }\n            }\n        }\n\n        if (_args.onDataWrap && !_noWrap) {\n            return _args.onDataWrap(_node, s, _args2);\n        }\n        return s;\n    }\n\n    /**\n     * Remove node(s) from tree.\n     *\n     * @param {object|string} _node Node or path.\n     * @param {array} [_interval] Remove nodes in this interval of indices into children array. `_node` is parent in this case.\n     * @param {boolean} [_isId]\n     * @return {boolean}\n     */\n    remove(_node, _interval, _isId) {\n        let node = this._getNode(_node, _isId);\n        let parent = null;\n        let idx = -1;\n        const options = this._options;\n        const dataPrepared = options.prepareData;\n        const { onBeforeDataNode } = options;\n        let interval = null;\n        let id;\n\n        if (!node) {\n            return false;\n        }\n\n        if (isArray(_interval)) {\n            interval = _interval;\n        } else {\n            idx = this.getNodeIdx(node);\n            interval = [idx, idx];\n        }\n\n        if (_interval) {\n            parent = node;\n        } else if (dataPrepared) {\n            parent = node._p;\n        }\n\n        for (let i = interval[0]; i <= interval[1]; i++) {\n            idx = interval[0];\n\n            /* if (parent && !parent._c) {\n                alert('WTT!!\\n' + this._utils.printObjectSimple(parent, true) + '\\n' + this._objectId + '\\n\\n' + this._utils.printObjectSimple(_node, true) + ' ... ' + _interval);\n            } */\n\n            node = parent ? parent._c[idx] : this.root;\n\n            if (dataPrepared) {\n                // delete reference from this.dataL object\n                id = this.getNodeId(node);\n                if (id) {\n                    if (options.onBeforeDataNodeRemove) {\n                        options.onBeforeDataNodeRemove(node);\n                    }\n\n                    // this.dataL[id] = null;\n                    delete this.dataL[id];\n                }\n\n                // delete reference from parent's children array\n                // parent = node._p;\n                if (parent) {\n                    parent._c[idx] = null;\n                    parent._c.splice(idx, 1);\n\n                    if (parent._c.length === 0) {\n                        delete parent._c;\n                    }\n                    /* idx = this.getNodeIdx(node);\n                    if (idx > -1) {\n                        parent._c[idx] = null;\n                        parent._c.splice(idx, 1);\n                    } */\n                }\n            }\n\n            if (onBeforeDataNode) {\n                onBeforeDataNode(node);\n            }\n\n            // prevent memory leaks - walk all nodes and \"null\" data\n            this.walk(node, this.removeWalkOptions);\n\n            if (node._p === null) {\n                // root\n                if (dataPrepared && this.dataL._root) {\n                    delete this.dataL._root;\n                }\n                node._c = null;\n            }\n\n            node = null;\n        }\n\n        return true;\n    }\n\n    /**\n     * Clear tree.\n     *\n     * @return {void}\n     */\n    clear() {\n        this.remove(this.root);\n        this.root._c = [];\n        this._cursor = this.root;\n    }\n\n    /**\n     * Get node.\n     *\n     * @param {object|string} _nodeOrPathOrId\n     * @param {boolean} [_isId] `_nodeOrPathOrId` is node's id.\n     * @return {object|null} Tree node.\n     */\n    _getNode(_nodeOrPathOrId, _isId) {\n        let node = _nodeOrPathOrId;\n\n        if (typeof _nodeOrPathOrId === 'string') {\n            if (_isId) {\n                node = this.get(_nodeOrPathOrId);\n            } else {\n                node = this.getNodeByPath(_nodeOrPathOrId);\n            }\n        }\n\n        return node;\n    }\n\n    /**\n     * Get node by path.\n     *\n     * @param {string} _path\n     * @param {boolean} [_pathCode]\n     * @return {object|null} Tree node.\n     */\n    getNodeByPath(_path, _pathCode) {\n        let path = _path.trim();\n        let pathA = null;\n        let ar = null;\n        let node = null;\n        let relativePath = false;\n        const pathCode = _pathCode || this._options.pathCode;\n        let children = null;\n        let idx = 0;\n        let found = false;\n        let quit = false;\n\n        if (path) {\n            if (path === '/') {\n                node = this.root;\n            } else {\n                pathA = path.split('/');\n                if (!pathA[0]) {\n                    // absolute path\n                    pathA.shift();\n                    node = this.root;\n                } else {\n                    // relative path\n                    relativePath = true;\n                    node = this._cursor;\n                }\n\n                for (let i = 0, len = pathA.length; i < len; i++) {\n                    path = pathA[i];\n\n                    if (relativePath && path === '..') {\n                        if (this._cursor._p !== null) {\n                            this._cursor = this._cursor._p;\n                            node = this._cursor;\n                        }\n                    } else {\n                        ar = path.split(':');\n\n                        children = node._c;\n                        if (children && children.length > 0) {\n                            idx = parseInt(ar[0]);\n                            if (!isNaN(idx)) {\n                                node = children[idx];\n                            } else {\n                                found = false;\n\n                                for (let j = 0, len2 = children.length; j < len2; j++) {\n                                    if (children[j][pathCode] === ar[0]) {\n                                        node = children[j];\n                                        found = true;\n                                        break;\n                                    }\n                                }\n\n                                if (!found) {\n                                    node = null;\n                                }\n                            }\n\n                            if (node) {\n                                if (ar.length === 2 && node[pathCode] !== ar[1]) {\n                                    quit = true;\n                                }\n                            } else {\n                                quit = true;\n                            }\n                        } else {\n                            quit = true;\n                        }\n\n                        if (quit) {\n                            node = null;\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n\n        return node;\n    }\n\n    /**\n     * Get path (absolute) of node.\n     *\n     * @param {object} [_node] Data node.\n     * @param {boolean} [_withPathCode] Get path with path code (`_type`).\n     * @param {string} [_pathCode] Path without index and with _pathCode.\n     * @return {string}\n     */\n    getPath(_node, _withPathCode, _pathCode) {\n        const node = _node || this.root;\n        const { pathCode } = this._options;\n        const aPath = [''];\n        let parents = null;\n        let path = '';\n\n        if (node === this.root) {\n            path = '/';\n        } else {\n            parents = this.getParents(node);\n            if (parents.length > 0) {\n                for (let i = parents.length - 1; i >= 0; i--) {\n                    if (_pathCode) {\n                        aPath.push(parents[i][_pathCode]);\n                    } else {\n                        aPath.push(\n                            this.getNodeIdx(parents[i]) +\n                            (_withPathCode ? `:${parents[i][pathCode]}` : ''),\n                        );\n                    }\n                }\n\n                path = aPath.join('/');\n            }\n        }\n\n        return path;\n    }\n\n    /**\n     * Set cursor to node defined by path or node.\n     *\n     * @param {object|string} _nodeOrPath\n     * @return {object|null} Cursor or null.\n     */\n    cd(_nodeOrPath) {\n        const node = this._getNode(_nodeOrPath);\n\n        if (node) {\n            this._cursor = node;\n        }\n\n        return node;\n    }\n\n    /**\n     * Get array of node's parents (including node itself).\n     *\n     * @param {*} _idOrNode\n     * @param {*} [_endParentNode] Id or node.\n     * @param {boolean} [_getObjectIds]\n     * @return {array} Array of nodes.\n     */\n    getParents(_idOrNode, _endParentNode, _getObjectIds) {\n        let node = this._getNode(_idOrNode, true);\n        const endParentNode = _endParentNode ? this._getNode(_endParentNode, true) : null;\n        const parents = [];\n\n        if (node) {\n            parents.push(_getObjectIds ? node._componentId : node);\n            node = node._p;\n            while (node && node._p !== endParentNode) {\n                parents.push(_getObjectIds ? node._componentId : node);\n                node = node._p;\n            }\n        }\n\n        return parents;\n    }\n\n    /**\n     * Get array of node's parents by an attribue (node is not included).\n     *\n     * @param {string|number|array} _val Value or array of values.\n     * @param {int|string} _key If data item is array then _key is index into that array, otherwise it's key of an object.\n     * @param {*} _idOrNode\n     * @param {*} [_endParentNode] Id or node.\n     * @param {boolean} [_getObjectIds]\n     * @param {boolean} [_getFirstParent] Get just first parent's match.\n     * @return {array|object|null} Array of nodes.\n     */\n    getParentsBy(_val, _key, _idOrNode, _endParentNode, _getObjectIds, _getFirstParent) {\n        let node = this._getNode(_idOrNode, true);\n        const endParentNode = _endParentNode ? this._getNode(_endParentNode, true) : null;\n        const parents = [];\n        const vals = isArray(_val) ? _val : [_val];\n\n        if (node) {\n            node = node._p;\n            while (node && node._p !== endParentNode) {\n                if (inArray(node[_key], vals) > -1) {\n                    parents.push(_getObjectIds ? node._componentId : node);\n\n                    if (_getFirstParent) {\n                        break;\n                    }\n                }\n\n                node = node._p;\n            }\n        }\n\n        if (!_getFirstParent) {\n            return parents;\n        }\n        if (parents.length > 0) {\n            return parents[0];\n        }\n        return null;\n    }\n\n    /**\n     * Get child of node by index.\n     *\n     * @param {object} _node\n     * @param {int} _idx\n     * @return {object|null} Node.\n     */\n    getChildByIdx(_node, _idx) {\n        let childNode = null;\n        let children = null;\n\n        if (_node && _idx >= 0) {\n            children = _node._c;\n            if (children && children.length > 0 && children[_idx] !== undefined) {\n                childNode = children[_idx];\n            }\n        }\n\n        return childNode;\n    }\n\n    /**\n     * @param {object} _node\n     * @return {object|null} Node.\n     */\n    getPrevNode(_node) {\n        return this._getPrevOrNextNode(_node);\n    }\n\n    /**\n     * @param {object} _node\n     * @return {object|null} Node.\n     */\n    getNextNode(_node) {\n        return this._getPrevOrNextNode(_node, true);\n    }\n\n    /**\n     * @param {object} _node\n     * @param {boolean} [_next]\n     * @return {object|null} Node.\n     */\n    _getPrevOrNextNode(_node, _next) {\n        let node = null;\n        let idx = -1;\n        let children = null;\n\n        if (_node) {\n            idx = this.getNodeIdx(_node);\n            if (idx > -1) {\n                children = _node._p._c;\n                if (children) {\n                    if (_next) {\n                        if (idx + 1 <= children.length - 1) {\n                            node = children[idx + 1];\n                        }\n                    } else if (idx - 1 >= 0) {\n                        node = children[idx - 1];\n                    }\n                }\n            }\n        }\n\n        return node;\n    }\n\n    /**\n     * Get child of node by index.\n     *\n     * @param {*} _idOrNode\n     * @return {Array}\n     */\n    getSiblings(_idOrNode) {\n        const node = this._getNode(_idOrNode, true);\n        const siblings = [];\n        let children;\n\n        if (node._p) {\n            children = node._p._c;\n            for (let i = 0, len1 = children.length; i < len1; i++) {\n                if (children[i] !== node) {\n                    siblings.push(children[i]);\n                }\n            }\n        }\n\n        return siblings;\n    }\n\n    /**\n     * Get node by id.\n     *\n     * @param {int|string} _id Id of node (index 0 or .id property).\n     * @return {object|null} Node.\n     */\n    get(_id) {\n        return this.dataL[_id] || null;\n    }\n\n    /**\n     * Get node(s) by value and key.\n     *\n     * @param {string|number} _val\n     * @param {int|string} _key If data item is array then _key is index into that array, otherwise it's key of an object.\n     * @param {boolean} [_findAll] If true, find all possible occurrences, otherwise find only the first one.\n     * @return {*} Item (or null) or array of items.\n     */\n    getBy(_val, _key, _findAll) {\n        const data = this.dataL;\n        let node = _findAll ? [] : null;\n        let n = null;\n\n        // get by id\n        if (_key === 'id') {\n            return this.get(_val);\n        }\n\n        for (const i in data) {\n            n = data[i];\n            if (n[_key] == _val) {\n                if (_findAll) {\n                    node.push(data[i]);\n                } else {\n                    node = data[i];\n                    break;\n                }\n            }\n        }\n\n        return node;\n    }\n\n    /**\n     * Get node(s) by value and key, search nodes recursively.\n     * If `_startNode` is specified, start searching from this node, it won't be\n     * included in search result.\n     *\n     * @param {string|number} _val\n     * @param {int|string} _key If data item is array then _key is index into that array, otherwise it's key of an object.\n     * @param {object|string} [_startNode] Start node or path.\n     * @param {boolean} [_findAll] If true, find all possible occurrences, otherwise find only the first one.\n     * @return {*} Item or array of items.\n     */\n    getByR(_val, _key, _startNode, _findAll) {\n        const startNode = this._getNode(_startNode) || this._root;\n        const nodes = [];\n        const self = this;\n\n        // get by id\n        if (_key === 'id') {\n            return this.get(_val);\n        }\n\n        this.walk(startNode, {\n            // walkType: 'render',\n            onDataWrap(_node) {\n                return self._getByR(_node, _val, _key, nodes, _findAll);\n            },\n            onDataNode(_node) {\n                return self._getByR(_node, _val, _key, nodes, _findAll);\n            },\n        });\n\n        for (let i = 0, len1 = nodes.length; i < len1; i++) {\n            delete nodes[i].__found;\n        }\n\n        if (_findAll) {\n            return nodes;\n        }\n        if (nodes.length > 0) {\n            return nodes[0];\n        }\n        return null;\n    }\n\n    /**\n     * Private function for tree walking in `getByR` method.\n     *\n     * @param {object} _node Tree node.\n     * @param {string|number} _val\n     * @param {int|string} _key If data item is array then _key is index into that array, otherwise it's key of an object.\n     * @param {array} _result\n     * @param {boolean} [_findAll] If true, find all possible occurrences, otherwise find only the first one.\n     * @return {boolean}\n     */\n    _getByR(_node, _val, _key, _result, _findAll) {\n        let found = false;\n\n        if (_node[_key] == _val) {\n            if (!_node.__found) {\n                _node.__found = true;\n                _result.push(_node);\n            }\n            found = true;\n        }\n\n        return !(!_findAll && found);\n    }\n\n    /**\n     * Find node's position (index) in `_node._p._c` array.\n     *\n     * @param {object} _node\n     * @return {int} -1 if fail.\n     */\n    getNodeIdx(_node) {\n        let children = null;\n\n        if (!_node || !_node._p || !_node._p._c) {\n            return -1;\n        }\n\n        children = _node._p._c;\n        for (let i = 0, len = children.length; i < len; i++) {\n            if (children[i] === _node) {\n                return i;\n            }\n        }\n\n        return -1;\n    }\n\n    /**\n     * Get node's id.\n     *\n     * @param {object} _node\n     * @return {*}\n     */\n    getNodeId(_node) {\n        if (_node) {\n            if (_node._p === null) {\n                // root\n                return 0;\n            }\n\n            return _node.id;\n        }\n        return 0;\n    }\n}\n"],"mappings":"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"}]}