{"remainingRequest":"/mnt/websites/ex.nextsmartchain.com/node_modules/thread-loader/dist/cjs.js!/mnt/websites/ex.nextsmartchain.com/node_modules/babel-loader/lib/index.js!/mnt/websites/ex.nextsmartchain.com/node_modules/cache-loader/dist/cjs.js??ref--1-0!/mnt/websites/ex.nextsmartchain.com/node_modules/vue-loader/lib/index.js??vue-loader-options!/mnt/websites/ex.nextsmartchain.com/src/components/core/FLightweightCharts/FLightweightCharts.vue?vue&type=script&lang=js&","dependencies":[{"path":"/mnt/websites/ex.nextsmartchain.com/src/components/core/FLightweightCharts/FLightweightCharts.vue","mtime":1657708592570},{"path":"/mnt/websites/ex.nextsmartchain.com/babel.config.js","mtime":1657708595230},{"path":"/mnt/websites/ex.nextsmartchain.com/node_modules/cache-loader/dist/cjs.js","mtime":1655491106804},{"path":"/mnt/websites/ex.nextsmartchain.com/node_modules/thread-loader/dist/cjs.js","mtime":1655491285854},{"path":"/mnt/websites/ex.nextsmartchain.com/node_modules/babel-loader/lib/index.js","mtime":1655491285588},{"path":"/mnt/websites/ex.nextsmartchain.com/node_modules/cache-loader/dist/cjs.js","mtime":1655491106804},{"path":"/mnt/websites/ex.nextsmartchain.com/node_modules/vue-loader/lib/index.js","mtime":1657708714280}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:aW1wb3J0IF9vYmplY3RTcHJlYWQgZnJvbSAiL21udC93ZWJzaXRlcy9leC5uZXh0c21hcnRjaGFpbi5jb20vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL29iamVjdFNwcmVhZDIuanMiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy5udW1iZXIuY29uc3RydWN0b3IuanMiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy5vYmplY3QudG8tc3RyaW5nLmpzIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvd2ViLmRvbS1jb2xsZWN0aW9ucy5mb3ItZWFjaC5qcyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC5rZXlzLmpzIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLnRyaW0uanMiOwppbXBvcnQgeyBjcmVhdGVDaGFydCB9IGZyb20gJ2xpZ2h0d2VpZ2h0LWNoYXJ0cyc7CmltcG9ydCB7IGlzQXJyYXksIHRocm90dGxlIH0gZnJvbSAnLi4vLi4vLi4vdXRpbHMnOwp2YXIgV0VJID0gMTAwMDAwMDAwMDAwMDAwMDAwMDsKLyoqCiAqIExpZ2h0d2VpZ2h0IGNoYXJ0IHNlcmllcyBvYmplY3QuCiAqIEB0eXBlZGVmIHtPYmplY3R9IExpZ2h0d2VpZ2h0U2VyaWVzCiAqIEBwcm9wZXJ0eSB7YXJyYXl9IHNlcmllcyBEYXRhIGZvciBzZXJpZXMuCiAqIEBwcm9wZXJ0eSB7KCdsaW5lJyB8ICdoaXN0b2dyYW0nIHwgJ2FyZWEnIHwgJ2JhcicgfCAnY2FuZGxlc3RpY2snKX0gc2VyaWVzVHlwZSBUeXBlIG9mIHNlcmllcy4KICogQHByb3BlcnR5IHsoJycgfCAndG8tZXRoJyl9IFt0cmFuc2Zvcm1WYWx1ZXNdCiAqLwoKLyoqCiAqIExpZ2h0d2VpZ2h0IGNoYXJ0cyB3cmFwcGVyLgogKiBodHRwczovL3d3dy50cmFkaW5ndmlldy5jb20vbGlnaHR3ZWlnaHQtY2hhcnRzLwogKi8KCmV4cG9ydCBkZWZhdWx0IHsKICBuYW1lOiAnRkxpZ2h0d2VpZ2h0Q2hhcnRzJywKICBwcm9wczogewogICAgLyoqCiAgICAgKiBEYXRhIGZvciBjaGFydC4KICAgICAqIEl0IGNhbiBiZSBzZXJpZXMgKGFycmF5IG9mIHNlcmllcyBkYXRhKSBvciBvYmplY3QsIHdoZXJlIGtleXMgYXJlIHVuaXF1ZSBzZXJpZXMgaWRzIGFuZCB2YWx1ZXMgYXJlIG9iamVjdHMKICAgICAqIG9mIHR5cGUgTGlnaHR3ZWlnaHRTZXJpZXMuCiAgICAgKiBAdHlwZSB7W10gfCB7a2V5OiBzdHJpbmcsIHNlcmllczogTGlnaHR3ZWlnaHRTZXJpZXN9fQogICAgICovCiAgICBzZXJpZXM6IHsKICAgICAgdHlwZTogW0FycmF5LCBPYmplY3RdLAogICAgICBkZWZhdWx0OiBmdW5jdGlvbiBfZGVmYXVsdCgpIHsKICAgICAgICByZXR1cm4gW107CiAgICAgIH0KICAgIH0sCgogICAgLyoqCiAgICAgKiBUeXBlIG9mIHNlcmllcy4KICAgICAqIEB0eXBlIHsoJ2xpbmUnIHwgJ2hpc3RvZ3JhbScgfCAnYXJlYScgfCAnYmFyJyB8ICdjYW5kbGVzdGljaycpfQogICAgICovCiAgICBzZXJpZXNUeXBlOiB7CiAgICAgIHR5cGU6IFN0cmluZywKICAgICAgZGVmYXVsdDogJ2xpbmUnLAogICAgICB2YWxpZGF0b3I6IGZ1bmN0aW9uIHZhbGlkYXRvcihfdmFsdWUpIHsKICAgICAgICByZXR1cm4gWydsaW5lJywgJ2hpc3RvZ3JhbScsICdhcmVhJywgJ2JhcicsICdjYW5kbGVzdGljayddLmluZGV4T2YoX3ZhbHVlKSAhPT0gLTE7CiAgICAgIH0KICAgIH0sCgogICAgLyoqIExpZ2h0d2VpZ2h0IGNoYXJ0J3Mgb3B0aW9ucy4gKi8KICAgIG9wdGlvbnM6IHsKICAgICAgdHlwZTogT2JqZWN0LAogICAgICBkZWZhdWx0OiBmdW5jdGlvbiBfZGVmYXVsdCgpIHsKICAgICAgICByZXR1cm4ge307CiAgICAgIH0KICAgIH0sCgogICAgLyoqIExpZ2h0d2VpZ2h0IGNoYXJ0J3Mgc2VyaWVzIG9wdGlvbnMuICovCiAgICBzZXJpZXNPcHRpb25zOiB7CiAgICAgIHR5cGU6IE9iamVjdCwKICAgICAgZGVmYXVsdDogZnVuY3Rpb24gX2RlZmF1bHQoKSB7CiAgICAgICAgcmV0dXJuIHt9OwogICAgICB9CiAgICB9LAoKICAgIC8qKiBDaGFydCBoZWlnaHQuICovCiAgICBoZWlnaHQ6IHsKICAgICAgdHlwZTogTnVtYmVyLAogICAgICBkZWZhdWx0OiAzMDAKICAgIH0sCgogICAgLyoqIEJhc2ljIGxpbmUgY29sb3IuICovCiAgICBjb2xvcjogewogICAgICB0eXBlOiBTdHJpbmcsCiAgICAgIGRlZmF1bHQ6ICcjMjA0MEZGJwogICAgfSwKCiAgICAvKiogRGVmYXVsdCBzY2FsZSB0b3AgbWFyZ2luICovCiAgICBzY2FsZU1hcmdpblRvcDogewogICAgICB0eXBlOiBOdW1iZXIsCiAgICAgIGRlZmF1bHQ6IDAuMQogICAgfSwKCiAgICAvKiogRGVmYXVsdCBzY2FsZSBib3R0b20gbWFyZ2luICovCiAgICBzY2FsZU1hcmdpbkJvdHRvbTogewogICAgICB0eXBlOiBOdW1iZXIsCiAgICAgIGRlZmF1bHQ6IDAuMDMKICAgIH0sCgogICAgLyoqCiAgICAgKiBAdHlwZSB7KCcnIHwgJ3RvLWV0aCcpfQogICAgICovCiAgICB0cmFuc2Zvcm1WYWx1ZXM6IHsKICAgICAgdHlwZTogU3RyaW5nLAogICAgICBkZWZhdWx0OiAnJywKICAgICAgdmFsaWRhdG9yOiBmdW5jdGlvbiB2YWxpZGF0b3IoX3ZhbHVlKSB7CiAgICAgICAgcmV0dXJuIFsnJywgJ3RvLWV0aCddLmluZGV4T2YoX3ZhbHVlKSAhPT0gLTE7CiAgICAgIH0KICAgIH0sCgogICAgLyoqIEluamVjdCBtaXNzaW5nIHZhbHVlcyAqLwogICAgYWRkTWlzc2luZ1ZhbHVlczogewogICAgICB0eXBlOiBPYmplY3QsCiAgICAgIGRlZmF1bHQ6IGZ1bmN0aW9uIF9kZWZhdWx0KCkgewogICAgICAgIHJldHVybiB7CiAgICAgICAgICB0aW1lUmVzb2x1dGlvbjogMCwKICAgICAgICAgIHZhbHVlOiAwCiAgICAgICAgfTsKICAgICAgfQogICAgfSwKCiAgICAvKioKICAgICAqIFRyYW5zZm9ybSBnaXZlbiBzZXJpZXMgdGltZSB0byB0aW1lc3RhbXAuCiAgICAgKi8KICAgIHRpbWVUb1RpbWVzdGFtcDogewogICAgICB0eXBlOiBCb29sZWFuLAogICAgICBkZWZhdWx0OiBmYWxzZQogICAgfSwKCiAgICAvKiogICovCiAgICBmaXRDb250ZW50OiB7CiAgICAgIHR5cGU6IEJvb2xlYW4sCiAgICAgIGRlZmF1bHQ6IGZhbHNlCiAgICB9LAoKICAgIC8qKiBEaXNhYmxlIGF1dG8gcmVzaXppbmcuICovCiAgICBub0F1dG9SZXNpemU6IHsKICAgICAgdHlwZTogQm9vbGVhbiwKICAgICAgZGVmYXVsdDogZmFsc2UKICAgIH0KICB9LAogIGRhdGE6IGZ1bmN0aW9uIGRhdGEoKSB7CiAgICByZXR1cm4gewogICAgICBkU2VyaWVzOiBbXSwKICAgICAgY2hhcnRPcHRpb25zOiB7fQogICAgfTsKICB9LAogIGNvbXB1dGVkOiB7CiAgICBjU2VyaWVzOiBmdW5jdGlvbiBjU2VyaWVzKCkgewogICAgICB2YXIgX3RoaXMgPSB0aGlzOwoKICAgICAgdmFyIHNlcmllcyA9IHRoaXMuc2VyaWVzOwogICAgICB2YXIgZGF0YSA9IHt9OwoKICAgICAgaWYgKGlzQXJyYXkoc2VyaWVzKSkgewogICAgICAgIGRhdGEuc2VyaWVzID0gewogICAgICAgICAgc2VyaWVzVHlwZTogdGhpcy5zZXJpZXNUeXBlLAogICAgICAgICAgc2VyaWVzT3B0aW9uczogdGhpcy5zZXJpZXNPcHRpb25zLAogICAgICAgICAgdHJhbnNmb3JtVmFsdWVzOiB0aGlzLnRyYW5zZm9ybVZhbHVlcywKICAgICAgICAgIHRpbWVUb1RpbWVzdGFtcDogdGhpcy50aW1lVG9UaW1lc3RhbXAsCiAgICAgICAgICBhZGRNaXNzaW5nVmFsdWVzOiB0aGlzLmFkZE1pc3NpbmdWYWx1ZXMsCiAgICAgICAgICBzZXJpZXM6IHNlcmllcwogICAgICAgIH07CiAgICAgIH0KCiAgICAgIGlmICghZGF0YS5zZXJpZXMpIHsKICAgICAgICBkYXRhID0gX29iamVjdFNwcmVhZCh7fSwgc2VyaWVzKTsKICAgICAgfQoKICAgICAgT2JqZWN0LmtleXMoZGF0YSkuZm9yRWFjaChmdW5jdGlvbiAoX3Nlcmllc0tleSkgewogICAgICAgIHZhciBpdGVtID0gZGF0YVtfc2VyaWVzS2V5XTsKCiAgICAgICAgaWYgKGl0ZW0udGltZVRvVGltZXN0YW1wIHx8IGl0ZW0uYWRkTWlzc2luZ1ZhbHVlcy50aW1lUmVzb2x1dGlvbiA+IDApIHsKICAgICAgICAgIF90aGlzLnRyYW5zZm9ybVRpbWVUb1RpbWVzdGFtcChpdGVtLnNlcmllcyk7CiAgICAgICAgfQoKICAgICAgICBpZiAoaXRlbS5hZGRNaXNzaW5nVmFsdWVzLnRpbWVSZXNvbHV0aW9uID4gMCkgewogICAgICAgICAgaXRlbS5zZXJpZXMgPSBfdGhpcy5pbmplY3RNaXNzaW5nVmFsdWVzKGl0ZW0uc2VyaWVzLCBpdGVtLmFkZE1pc3NpbmdWYWx1ZXMpOwogICAgICAgIH0KCiAgICAgICAgaWYgKGl0ZW0udHJhbnNmb3JtVmFsdWVzKSB7CiAgICAgICAgICBpZiAoaXRlbS50cmFuc2Zvcm1WYWx1ZXMgPT09ICd0by1ldGgnKSB7CiAgICAgICAgICAgIGl0ZW0uc2VyaWVzID0gX3RoaXMudHJhbnNmb3JtVmFsdWVzVG9ORVhUKGl0ZW0uc2VyaWVzKTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH0pOwogICAgICByZXR1cm4gZGF0YTsKICAgIH0KICB9LAogIHdhdGNoOiB7CiAgICBzZXJpZXM6IGZ1bmN0aW9uIHNlcmllcygpIHsKICAgICAgdGhpcy5pbml0Q2hhcnQoKTsgLy8gdGhpcy5pbml0U2VyaWVzKCk7CiAgICB9CiAgfSwKICBjcmVhdGVkOiBmdW5jdGlvbiBjcmVhdGVkKCkgewogICAgdmFyIF90aGlzMiA9IHRoaXM7CgogICAgLyoqIExpZ2h0d2VpZ2h0IGNoYXJ0IGluc3RhbmNlLiAqLwogICAgdGhpcy5fY2hhcnQgPSBudWxsOwogICAgLyoqIEFycmF5IG9mIExpZ2h0d2VpZ2h0IGNoYXJ0IHNlcmllcyBpbnN0YW5jZXMuICovCgogICAgdGhpcy5fc2VyaWVzID0ge307CiAgICAvKiogRGVib3VuY2UgZnVuY3Rpb24gdXNlZCBhcyB3aW5kb3cgcmVzaXplIGNhbGxiYWNrLiAqLwoKICAgIHRoaXMuX3Jlc2l6ZUNhbGxiYWNrID0gdGhyb3R0bGUoZnVuY3Rpb24gKF9ldmVudCkgewogICAgICByZXR1cm4gX3RoaXMyLm9uV2luZG93UmVzaXplKF9ldmVudCk7CiAgICB9LCAzMDAsIHRydWUpOwogIH0sCiAgbW91bnRlZDogZnVuY3Rpb24gbW91bnRlZCgpIHsKICAgIC8vIHRoaXMuaW5pdENoYXJ0KCk7CiAgICBpZiAoIXRoaXMubm9BdXRvUmVzaXplKSB7CiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCB0aGlzLl9yZXNpemVDYWxsYmFjaywgZmFsc2UpOwogICAgfQogIH0sCiAgYmVmb3JlRGVzdHJveTogZnVuY3Rpb24gYmVmb3JlRGVzdHJveSgpIHsKICAgIHRoaXMuZGVzdHJveUNoYXJ0KCk7CgogICAgaWYgKCF0aGlzLm5vQXV0b1Jlc2l6ZSkgewogICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdGhpcy5fcmVzaXplQ2FsbGJhY2spOwogICAgfQogIH0sCiAgbWV0aG9kczogewogICAgaW5pdENoYXJ0OiBmdW5jdGlvbiBpbml0Q2hhcnQoKSB7CiAgICAgIHZhciBkZWZhdWx0T3B0aW9ucyA9IHsKICAgICAgICBoZWlnaHQ6IHRoaXMuaGVpZ2h0LAogICAgICAgIHByaWNlU2NhbGU6IHt9CiAgICAgIH07CiAgICAgIHRoaXMuZGVzdHJveUNoYXJ0KCk7CiAgICAgIHRoaXMuY2hhcnRPcHRpb25zID0gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBkZWZhdWx0T3B0aW9ucyksIHRoaXMub3B0aW9ucyk7CgogICAgICBpZiAoIXRoaXMuY2hhcnRPcHRpb25zLnByaWNlU2NhbGUuc2NhbGVNYXJnaW5zKSB7CiAgICAgICAgdGhpcy5jaGFydE9wdGlvbnMucHJpY2VTY2FsZS5zY2FsZU1hcmdpbnMgPSB7CiAgICAgICAgICB0b3A6IHRoaXMuc2NhbGVNYXJnaW5Ub3AsCiAgICAgICAgICBib3R0b206IHRoaXMuc2NhbGVNYXJnaW5Cb3R0b20KICAgICAgICB9OwogICAgICB9CgogICAgICB0aGlzLl9jaGFydCA9IGNyZWF0ZUNoYXJ0KHRoaXMuJHJlZnMuY2hhcnRDb250YWluZXIsIHRoaXMuY2hhcnRPcHRpb25zKTsKICAgICAgdGhpcy5pbml0U2VyaWVzKCk7CiAgICB9LAogICAgaW5pdFNlcmllczogZnVuY3Rpb24gaW5pdFNlcmllcygpIHsKICAgICAgdmFyIF90aGlzMyA9IHRoaXM7CgogICAgICB0aGlzLl9zZXJpZXMgPSB7fTsKICAgICAgT2JqZWN0LmtleXModGhpcy5jU2VyaWVzKS5mb3JFYWNoKGZ1bmN0aW9uIChfc2VyaWVzS2V5KSB7CiAgICAgICAgX3RoaXMzLmFkZFNlcmllcyhfc2VyaWVzS2V5KTsKICAgICAgfSk7CiAgICAgIHRoaXMudXBkYXRlQ29sb3JzKCk7CgogICAgICBpZiAodGhpcy5maXRDb250ZW50KSB7CiAgICAgICAgdGhpcy5fY2hhcnQudGltZVNjYWxlKCkuZml0Q29udGVudCgpOwogICAgICB9CiAgICB9LAogICAgYWRkU2VyaWVzOiBmdW5jdGlvbiBhZGRTZXJpZXMoX3Nlcmllc0tleSkgewogICAgICB2YXIgY2hhcnQgPSB0aGlzLl9jaGFydDsKICAgICAgdmFyIHNlcmllc09iaiA9IHRoaXMuY1Nlcmllc1tfc2VyaWVzS2V5XTsKCiAgICAgIGlmICghY2hhcnQgfHwgIXNlcmllc09iaikgewogICAgICAgIHJldHVybjsKICAgICAgfQoKICAgICAgdmFyIGRlZmF1bHRTZXJpZXNPcHRpb25zID0gey8vIGNvbG9yOiB0aGlzLmNvbG9yLAogICAgICB9OwoKICAgICAgdmFyIHNlcmllc09wdGlvbnMgPSBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIGRlZmF1bHRTZXJpZXNPcHRpb25zKSwgc2VyaWVzT2JqLnNlcmllc09wdGlvbnMpOwoKICAgICAgdmFyIHNlcmllcyA9IG51bGw7CgogICAgICBzd2l0Y2ggKHNlcmllc09iai5zZXJpZXNUeXBlKSB7CiAgICAgICAgY2FzZSAnbGluZSc6CiAgICAgICAgICBzZXJpZXMgPSBjaGFydC5hZGRMaW5lU2VyaWVzKHNlcmllc09wdGlvbnMpOwogICAgICAgICAgYnJlYWs7CgogICAgICAgIGNhc2UgJ2hpc3RvZ3JhbSc6CiAgICAgICAgICBzZXJpZXMgPSBjaGFydC5hZGRIaXN0b2dyYW1TZXJpZXMoc2VyaWVzT3B0aW9ucyk7CiAgICAgICAgICBicmVhazsKCiAgICAgICAgY2FzZSAnYXJlYSc6CiAgICAgICAgICBzZXJpZXMgPSBjaGFydC5hZGRBcmVhU2VyaWVzKHNlcmllc09wdGlvbnMpOwogICAgICAgICAgYnJlYWs7CgogICAgICAgIGNhc2UgJ2Jhcic6CiAgICAgICAgICBzZXJpZXMgPSBjaGFydC5hZGRCYXJTZXJpZXMoc2VyaWVzT3B0aW9ucyk7CiAgICAgICAgICBicmVhazsKCiAgICAgICAgY2FzZSAnY2FuZGxlc3RpY2snOgogICAgICAgICAgc2VyaWVzID0gY2hhcnQuYWRkQ2FuZGxlc3RpY2tTZXJpZXMoc2VyaWVzT3B0aW9ucyk7CiAgICAgICAgICBicmVhazsKICAgICAgfQoKICAgICAgaWYgKHNlcmllcykgewogICAgICAgIHNlcmllcy5zZXREYXRhKHNlcmllc09iai5zZXJpZXMpOwogICAgICAgIHRoaXMuX3Nlcmllc1tfc2VyaWVzS2V5XSA9IHNlcmllczsKICAgICAgfQogICAgfSwKICAgIHRyYW5zZm9ybVZhbHVlc1RvTkVYVDogZnVuY3Rpb24gdHJhbnNmb3JtVmFsdWVzVG9ORVhUKF9zZXJpZXMpIHsKICAgICAgdmFyIGRhdGEgPSBbXTsKICAgICAgdmFyIGl0ZW07CgogICAgICBpZiAoX3NlcmllcykgewogICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4xID0gX3Nlcmllcy5sZW5ndGg7IGkgPCBsZW4xOyBpKyspIHsKICAgICAgICAgIGl0ZW0gPSBfc2VyaWVzW2ldOwogICAgICAgICAgZGF0YS5wdXNoKF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgaXRlbSksIHt9LCB7CiAgICAgICAgICAgIHZhbHVlOiBwYXJzZUludChpdGVtLnZhbHVlLCAxNikgLyBXRUkKICAgICAgICAgIH0pKTsKICAgICAgICB9CiAgICAgIH0KCiAgICAgIHJldHVybiBkYXRhOwogICAgfSwKICAgIHRyYW5zZm9ybVRpbWVUb1RpbWVzdGFtcDogZnVuY3Rpb24gdHJhbnNmb3JtVGltZVRvVGltZXN0YW1wKF9zZXJpZXMpIHsKICAgICAgdmFyIGRhdGU7CgogICAgICBpZiAoX3NlcmllcykgewogICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4xID0gX3Nlcmllcy5sZW5ndGg7IGkgPCBsZW4xOyBpKyspIHsKICAgICAgICAgIGRhdGUgPSBuZXcgRGF0ZShfc2VyaWVzW2ldLnRpbWUpOwogICAgICAgICAgX3Nlcmllc1tpXS50aW1lID0gTWF0aC5mbG9vcihkYXRlLmdldFRpbWUoKSAvIDEwMDApOwogICAgICAgIH0KICAgICAgfQogICAgfSwKICAgIGluamVjdE1pc3NpbmdWYWx1ZXM6IGZ1bmN0aW9uIGluamVjdE1pc3NpbmdWYWx1ZXMoX3NlcmllcywgX29wdGlvbnMpIHsKICAgICAgdmFyIGRhdGEgPSBbXTsKICAgICAgdmFyIHByZXZJdGVtOwogICAgICB2YXIgaXRlbTsKICAgICAgdmFyIGRpZmYgPSAwOwogICAgICB2YXIgdGltZVJlc29sdXRpb24gPSBfb3B0aW9ucy50aW1lUmVzb2x1dGlvbjsKICAgICAgdmFyIHZhbHVlID0gX29wdGlvbnMudmFsdWU7CiAgICAgIHZhciB1c2VMYXN0VmFsdWUgPSB2YWx1ZSA9PT0gJ2xhc3QnOwoKICAgICAgaWYgKF9zZXJpZXMgJiYgdGltZVJlc29sdXRpb24gPiAwKSB7CiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbjEgPSBfc2VyaWVzLmxlbmd0aDsgaSA8IGxlbjE7IGkrKykgewogICAgICAgICAgaXRlbSA9IF9zZXJpZXNbaV07CgogICAgICAgICAgaWYgKGkgPiAwKSB7CiAgICAgICAgICAgIHByZXZJdGVtID0gX3Nlcmllc1tpIC0gMV07CiAgICAgICAgICAgIGRpZmYgPSBpdGVtLnRpbWUgLSBwcmV2SXRlbS50aW1lOwoKICAgICAgICAgICAgaWYgKGRpZmYgPiB0aW1lUmVzb2x1dGlvbikgewogICAgICAgICAgICAgIGZvciAodmFyIGogPSAxLCBsZW4yID0gcGFyc2VJbnQoZGlmZiAvIHRpbWVSZXNvbHV0aW9uKTsgaiA8IGxlbjI7IGorKykgewogICAgICAgICAgICAgICAgZGF0YS5wdXNoKHsKICAgICAgICAgICAgICAgICAgdGltZTogcHJldkl0ZW0udGltZSArIGogKiB0aW1lUmVzb2x1dGlvbiwKICAgICAgICAgICAgICAgICAgdmFsdWU6IHVzZUxhc3RWYWx1ZSA/IHByZXZJdGVtLnZhbHVlIDogdmFsdWUKICAgICAgICAgICAgICAgIH0pOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQogICAgICAgICAgfQoKICAgICAgICAgIGRhdGEucHVzaChfb2JqZWN0U3ByZWFkKHt9LCBpdGVtKSk7CiAgICAgICAgfQogICAgICB9CgogICAgICByZXR1cm4gZGF0YTsKICAgIH0sCiAgICB1cGRhdGVDb2xvcnM6IGZ1bmN0aW9uIHVwZGF0ZUNvbG9ycygpIHsKICAgICAgdmFyIGNoYXJ0Q1AgPSB0aGlzLmdldENoYXJ0Q3VzdG9tUHJvcGVydGllcygpOwogICAgICB2YXIgc2VyaWVzID0gdGhpcy5fc2VyaWVzOwogICAgICB2YXIgY1NlcmllcyA9IHRoaXMuY1NlcmllczsKICAgICAgdmFyIGNoYXJ0T3B0aW9ucyA9IHRoaXMuY2hhcnRPcHRpb25zOwogICAgICB2YXIgb3B0aW9ucyA9IHsKICAgICAgICBncmlkOiB7fSwKICAgICAgICBsYXlvdXQ6IHt9LAogICAgICAgIHRpbWVTY2FsZToge30sCiAgICAgICAgcHJpY2VTY2FsZToge30KICAgICAgfTsKCiAgICAgIHZhciBncmlkID0gX29iamVjdFNwcmVhZCh7fSwgY2hhcnRPcHRpb25zLmdyaWQpOwoKICAgICAgdmFyIGxheW91dCA9IF9vYmplY3RTcHJlYWQoe30sIGNoYXJ0T3B0aW9ucy5sYXlvdXQpOwoKICAgICAgdmFyIHRpbWVTY2FsZSA9IF9vYmplY3RTcHJlYWQoe30sIGNoYXJ0T3B0aW9ucy50aW1lU2NhbGUpOwoKICAgICAgdmFyIHByaWNlU2NhbGUgPSBfb2JqZWN0U3ByZWFkKHt9LCBjaGFydE9wdGlvbnMucHJpY2VTY2FsZSk7CgogICAgICBpZiAoY2hhcnRDUC52ZXJ0TGluZXNDb2xvciAmJiAoIWdyaWQudmVydExpbmVzIHx8ICFncmlkLnZlcnRMaW5lcy5jb2xvcikpIHsKICAgICAgICBvcHRpb25zLmdyaWQudmVydExpbmVzID0gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBncmlkLnZlcnRMaW5lcyksIHt9LCB7CiAgICAgICAgICBjb2xvcjogY2hhcnRDUC52ZXJ0TGluZXNDb2xvcgogICAgICAgIH0pOwogICAgICB9CgogICAgICBpZiAoY2hhcnRDUC5ob3J6TGluZXNDb2xvciAmJiAoIWdyaWQuaG9yekxpbmVzIHx8ICFncmlkLmhvcnpMaW5lcy5jb2xvcikpIHsKICAgICAgICBvcHRpb25zLmdyaWQuaG9yekxpbmVzID0gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBncmlkLmhvcnpMaW5lcyksIHt9LCB7CiAgICAgICAgICBjb2xvcjogY2hhcnRDUC5ob3J6TGluZXNDb2xvcgogICAgICAgIH0pOwogICAgICB9CgogICAgICBbJ2JhY2tncm91bmRDb2xvcicsICd0ZXh0Q29sb3InLCAnZm9udFNpemUnLCAnZm9udEZhbWlseSddLmZvckVhY2goZnVuY3Rpb24gKF9wcm9wKSB7CiAgICAgICAgaWYgKGNoYXJ0Q1BbX3Byb3BdICYmICFsYXlvdXRbX3Byb3BdKSB7CiAgICAgICAgICBvcHRpb25zLmxheW91dFtfcHJvcF0gPSBfcHJvcCA9PT0gJ2ZvbnRTaXplJyA/IHBhcnNlSW50KGNoYXJ0Q1BbX3Byb3BdKSA6IGNoYXJ0Q1BbX3Byb3BdOwogICAgICAgIH0KICAgICAgfSk7CgogICAgICBpZiAoY2hhcnRDUC50aW1lU2NhbGVCb3JkZXJDb2xvciAmJiAhdGltZVNjYWxlLmJvcmRlckNvbG9yKSB7CiAgICAgICAgb3B0aW9ucy50aW1lU2NhbGUuYm9yZGVyQ29sb3IgPSBjaGFydENQLnRpbWVTY2FsZUJvcmRlckNvbG9yOwogICAgICB9CgogICAgICBpZiAoY2hhcnRDUC5wcmljZVNjYWxlQm9yZGVyQ29sb3IgJiYgIXByaWNlU2NhbGUuYm9yZGVyQ29sb3IpIHsKICAgICAgICBvcHRpb25zLnByaWNlU2NhbGUuYm9yZGVyQ29sb3IgPSBjaGFydENQLnByaWNlU2NhbGVCb3JkZXJDb2xvcjsKICAgICAgfQoKICAgICAgdGhpcy5fY2hhcnQuYXBwbHlPcHRpb25zKG9wdGlvbnMpOwoKICAgICAgT2JqZWN0LmtleXMoc2VyaWVzKS5mb3JFYWNoKGZ1bmN0aW9uIChfc2VyaWVzS2V5KSB7CiAgICAgICAgdmFyIGl0ZW0gPSBjU2VyaWVzW19zZXJpZXNLZXldOwoKICAgICAgICB2YXIgc2VyaWVzT3B0aW9ucyA9IF9vYmplY3RTcHJlYWQoe30sIGl0ZW0uc2VyaWVzT3B0aW9ucyk7CgogICAgICAgIGlmICghaXRlbSkgewogICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KCiAgICAgICAgaWYgKGNoYXJ0Q1AubGluZUNvbG9yICYmICghc2VyaWVzT3B0aW9ucyB8fCAhc2VyaWVzT3B0aW9ucy5jb2xvcikpIHsKICAgICAgICAgIHNlcmllc1tfc2VyaWVzS2V5XS5hcHBseU9wdGlvbnMoewogICAgICAgICAgICBjb2xvcjogY2hhcnRDUC5saW5lQ29sb3IsCiAgICAgICAgICAgIGxpbmVDb2xvcjogY2hhcnRDUC5saW5lQ29sb3IsCiAgICAgICAgICAgIHRvcENvbG9yOiBjaGFydENQLnRvcENvbG9yLAogICAgICAgICAgICBib3R0b21Db2xvcjogY2hhcnRDUC5ib3R0b21Db2xvciwKICAgICAgICAgICAgbGluZVdpZHRoOiBjaGFydENQLmxpbmVXaWR0aAogICAgICAgICAgfSk7CiAgICAgICAgfQogICAgICB9KTsKICAgIH0sCiAgICBnZXRDaGFydEN1c3RvbVByb3BlcnRpZXM6IGZ1bmN0aW9uIGdldENoYXJ0Q3VzdG9tUHJvcGVydGllcygpIHsKICAgICAgdmFyIHN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzLiRlbCk7CiAgICAgIHZhciBjcCA9IHsKICAgICAgICBsaW5lQ29sb3I6IHN0eWxlLmdldFByb3BlcnR5VmFsdWUoJy0tZi1saWdodHdlaWdodC1jaGFydC1jaGFydC1saW5lLWNvbG9yJyksCiAgICAgICAgdGV4dENvbG9yOiBzdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKCctLWYtbGlnaHR3ZWlnaHQtY2hhcnQtY2hhcnQtdGV4dC1jb2xvcicpLAogICAgICAgIHRvcENvbG9yOiBzdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKCctLWYtbGlnaHR3ZWlnaHQtY2hhcnQtY2hhcnQtdG9wLWNvbG9yJyksCiAgICAgICAgYm90dG9tQ29sb3I6IHN0eWxlLmdldFByb3BlcnR5VmFsdWUoJy0tZi1saWdodHdlaWdodC1jaGFydC1jaGFydC1ib3R0b20tY29sb3InKSwKICAgICAgICBsaW5lV2lkdGg6IHN0eWxlLmdldFByb3BlcnR5VmFsdWUoJy0tZi1saWdodHdlaWdodC1jaGFydC1jaGFydC1saW5lLXdpZHRoJyksCiAgICAgICAgdmVydExpbmVzQ29sb3I6IHN0eWxlLmdldFByb3BlcnR5VmFsdWUoJy0tZi1saWdodHdlaWdodC1jaGFydC1jaGFydC12ZXJ0LWxpbmVzLWNvbG9yJyksCiAgICAgICAgaG9yekxpbmVzQ29sb3I6IHN0eWxlLmdldFByb3BlcnR5VmFsdWUoJy0tZi1saWdodHdlaWdodC1jaGFydC1jaGFydC1ob3J6LWxpbmVzLWNvbG9yJyksCiAgICAgICAgYmFja2dyb3VuZENvbG9yOiBzdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKCctLWYtbGlnaHR3ZWlnaHQtY2hhcnQtY2hhcnQtYmFja2dyb3VuZC1jb2xvcicpLAogICAgICAgIGZvbnRTaXplOiBzdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKCctLWYtbGlnaHR3ZWlnaHQtY2hhcnQtY2hhcnQtZm9udC1zaXplJyksCiAgICAgICAgZm9udEZhbWlseTogc3R5bGUuZ2V0UHJvcGVydHlWYWx1ZSgnLS1mLWxpZ2h0d2VpZ2h0LWNoYXJ0LWNoYXJ0LWZvbnQtZmFtaWx5JyksCiAgICAgICAgdGltZVNjYWxlQm9yZGVyQ29sb3I6IHN0eWxlLmdldFByb3BlcnR5VmFsdWUoJy0tZi1saWdodHdlaWdodC1jaGFydC1jaGFydC10aW1lLXNjYWxlLWJvcmRlci1jb2xvcicpLAogICAgICAgIHByaWNlU2NhbGVCb3JkZXJDb2xvcjogc3R5bGUuZ2V0UHJvcGVydHlWYWx1ZSgnLS1mLWxpZ2h0d2VpZ2h0LWNoYXJ0LWNoYXJ0LXByaWNlLXNjYWxlLWJvcmRlci1jb2xvcicpCiAgICAgIH07CiAgICAgIE9iamVjdC5rZXlzKGNwKS5mb3JFYWNoKGZ1bmN0aW9uIChfa2V5KSB7CiAgICAgICAgdmFyIGNvbG9yID0gY3BbX2tleV07CgogICAgICAgIGlmIChjb2xvcikgewogICAgICAgICAgY3BbX2tleV0gPSBjb2xvci50cmltKCk7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIGRlbGV0ZSBjcFtfa2V5XTsKICAgICAgICB9CiAgICAgIH0pOwogICAgICByZXR1cm4gY3A7CiAgICB9LAogICAgZGVzdHJveUNoYXJ0OiBmdW5jdGlvbiBkZXN0cm95Q2hhcnQoKSB7CiAgICAgIGlmICh0aGlzLl9jaGFydCkgewogICAgICAgIHRoaXMuX3NlcmllcyA9IHt9OwoKICAgICAgICB0aGlzLl9jaGFydC5yZW1vdmUoKTsKCiAgICAgICAgdGhpcy5fY2hhcnQgPSBudWxsOwogICAgICB9CiAgICB9LAogICAgb25XaW5kb3dSZXNpemU6IGZ1bmN0aW9uIG9uV2luZG93UmVzaXplKCkgewogICAgICB2YXIgY2hhcnQgPSB0aGlzLl9jaGFydDsKCiAgICAgIGlmIChjaGFydCkgewogICAgICAgIGNoYXJ0LnJlc2l6ZSh0aGlzLiRyZWZzLmNoYXJ0Q29udGFpbmVyLmNsaWVudFdpZHRoLCB0aGlzLmhlaWdodCk7CiAgICAgIH0KICAgIH0KICB9Cn07"},{"version":3,"mappings":"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","names":["name","props","series","type","default","seriesType","validator","options","seriesOptions","height","color","scaleMarginTop","scaleMarginBottom","transformValues","addMissingValues","timeResolution","value","timeToTimestamp","fitContent","noAutoResize","data","dSeries","chartOptions","computed","cSeries","Object","item","watch","created","mounted","window","beforeDestroy","methods","initChart","priceScale","defaultOptions","top","bottom","initSeries","addSeries","_seriesKey","defaultSeriesOptions","seriesObj","transformValuesToNEXT","_series","transformTimeToTimestamp","date","injectMissingValues","_options","prevItem","diff","time","updateColors","grid","layout","timeScale","lineColor","topColor","bottomColor","lineWidth","getChartCustomProperties","textColor","vertLinesColor","horzLinesColor","backgroundColor","fontSize","fontFamily","timeScaleBorderColor","priceScaleBorderColor","cp","destroyChart","onWindowResize","chart"],"sourceRoot":"src/components/core/FLightweightCharts","sources":["FLightweightCharts.vue"],"sourcesContent":["<template>\n    <div class=\"f-lightweight-chart\">\n        <slot name=\"top\"></slot>\n        <div ref=\"chartContainer\" class=\"f-lightweight-chart__container\"></div>\n        <slot name=\"bottom\"></slot>\n    </div>\n</template>\n\n<script>\nimport { createChart } from 'lightweight-charts';\nimport { isArray, throttle } from '../../../utils';\n\nconst WEI = 1000000000000000000;\n\n/**\n * Lightweight chart series object.\n * @typedef {Object} LightweightSeries\n * @property {array} series Data for series.\n * @property {('line' | 'histogram' | 'area' | 'bar' | 'candlestick')} seriesType Type of series.\n * @property {('' | 'to-eth')} [transformValues]\n */\n\n/**\n * Lightweight charts wrapper.\n * https://www.tradingview.com/lightweight-charts/\n */\nexport default {\n    name: 'FLightweightCharts',\n\n    props: {\n        /**\n         * Data for chart.\n         * It can be series (array of series data) or object, where keys are unique series ids and values are objects\n         * of type LightweightSeries.\n         * @type {[] | {key: string, series: LightweightSeries}}\n         */\n        series: {\n            type: [Array, Object],\n            default() {\n                return [];\n            },\n        },\n        /**\n         * Type of series.\n         * @type {('line' | 'histogram' | 'area' | 'bar' | 'candlestick')}\n         */\n        seriesType: {\n            type: String,\n            default: 'line',\n            validator: function (_value) {\n                return ['line', 'histogram', 'area', 'bar', 'candlestick'].indexOf(_value) !== -1;\n            },\n        },\n        /** Lightweight chart's options. */\n        options: {\n            type: Object,\n            default() {\n                return {};\n            },\n        },\n        /** Lightweight chart's series options. */\n        seriesOptions: {\n            type: Object,\n            default() {\n                return {};\n            },\n        },\n        /** Chart height. */\n        height: {\n            type: Number,\n            default: 300,\n        },\n        /** Basic line color. */\n        color: {\n            type: String,\n            default: '#2040FF',\n        },\n        /** Default scale top margin */\n        scaleMarginTop: {\n            type: Number,\n            default: 0.1,\n        },\n        /** Default scale bottom margin */\n        scaleMarginBottom: {\n            type: Number,\n            default: 0.03,\n        },\n        /**\n         * @type {('' | 'to-eth')}\n         */\n        transformValues: {\n            type: String,\n            default: '',\n            validator: function (_value) {\n                return ['', 'to-eth'].indexOf(_value) !== -1;\n            },\n        },\n        /** Inject missing values */\n        addMissingValues: {\n            type: Object,\n            default() {\n                return {\n                    timeResolution: 0,\n                    value: 0,\n                };\n            },\n        },\n        /**\n         * Transform given series time to timestamp.\n         */\n        timeToTimestamp: {\n            type: Boolean,\n            default: false,\n        },\n        /**  */\n        fitContent: {\n            type: Boolean,\n            default: false,\n        },\n        /** Disable auto resizing. */\n        noAutoResize: {\n            type: Boolean,\n            default: false,\n        },\n    },\n\n    data() {\n        return {\n            dSeries: [],\n            chartOptions: {},\n        };\n    },\n\n    computed: {\n        cSeries() {\n            const { series } = this;\n            let data = {};\n\n            if (isArray(series)) {\n                data.series = {\n                    seriesType: this.seriesType,\n                    seriesOptions: this.seriesOptions,\n                    transformValues: this.transformValues,\n                    timeToTimestamp: this.timeToTimestamp,\n                    addMissingValues: this.addMissingValues,\n                    series: series,\n                };\n            }\n\n            if (!data.series) {\n                data = { ...series };\n            }\n\n            Object.keys(data).forEach((_seriesKey) => {\n                const item = data[_seriesKey];\n\n                if (item.timeToTimestamp || item.addMissingValues.timeResolution > 0) {\n                    this.transformTimeToTimestamp(item.series);\n                }\n\n                if (item.addMissingValues.timeResolution > 0) {\n                    item.series = this.injectMissingValues(item.series, item.addMissingValues);\n                }\n\n                if (item.transformValues) {\n                    if (item.transformValues === 'to-eth') {\n                        item.series = this.transformValuesToNEXT(item.series);\n                    }\n                }\n            });\n\n            return data;\n        },\n    },\n\n    watch: {\n        series() {\n            this.initChart();\n            // this.initSeries();\n        },\n    },\n\n    created() {\n        /** Lightweight chart instance. */\n        this._chart = null;\n        /** Array of Lightweight chart series instances. */\n        this._series = {};\n        /** Debounce function used as window resize callback. */\n        this._resizeCallback = throttle((_event) => this.onWindowResize(_event), 300, true);\n    },\n\n    mounted() {\n        // this.initChart();\n\n        if (!this.noAutoResize) {\n            window.addEventListener('resize', this._resizeCallback, false);\n        }\n    },\n\n    beforeDestroy() {\n        this.destroyChart();\n\n        if (!this.noAutoResize) {\n            window.removeEventListener('resize', this._resizeCallback);\n        }\n    },\n\n    methods: {\n        initChart() {\n            const defaultOptions = {\n                height: this.height,\n                priceScale: {},\n            };\n\n            this.destroyChart();\n\n            this.chartOptions = {\n                ...defaultOptions,\n                ...this.options,\n            };\n\n            if (!this.chartOptions.priceScale.scaleMargins) {\n                this.chartOptions.priceScale.scaleMargins = {\n                    top: this.scaleMarginTop,\n                    bottom: this.scaleMarginBottom,\n                };\n            }\n\n            this._chart = createChart(this.$refs.chartContainer, this.chartOptions);\n\n            this.initSeries();\n        },\n\n        initSeries() {\n            this._series = {};\n\n            Object.keys(this.cSeries).forEach((_seriesKey) => {\n                this.addSeries(_seriesKey);\n            });\n\n            this.updateColors();\n\n            if (this.fitContent) {\n                this._chart.timeScale().fitContent();\n            }\n        },\n\n        addSeries(_seriesKey) {\n            const chart = this._chart;\n            const seriesObj = this.cSeries[_seriesKey];\n\n            if (!chart || !seriesObj) {\n                return;\n            }\n\n            const defaultSeriesOptions = {\n                // color: this.color,\n            };\n            const seriesOptions = {\n                ...defaultSeriesOptions,\n                ...seriesObj.seriesOptions,\n            };\n            let series = null;\n\n            switch (seriesObj.seriesType) {\n                case 'line':\n                    series = chart.addLineSeries(seriesOptions);\n                    break;\n                case 'histogram':\n                    series = chart.addHistogramSeries(seriesOptions);\n                    break;\n                case 'area':\n                    series = chart.addAreaSeries(seriesOptions);\n                    break;\n                case 'bar':\n                    series = chart.addBarSeries(seriesOptions);\n                    break;\n                case 'candlestick':\n                    series = chart.addCandlestickSeries(seriesOptions);\n                    break;\n            }\n\n            if (series) {\n                series.setData(seriesObj.series);\n                this._series[_seriesKey] = series;\n            }\n        },\n\n        transformValuesToNEXT(_series) {\n            let data = [];\n            let item;\n\n            if (_series) {\n                for (let i = 0, len1 = _series.length; i < len1; i++) {\n                    item = _series[i];\n\n                    data.push({\n                        ...item,\n                        value: parseInt(item.value, 16) / WEI,\n                    });\n                }\n            }\n\n            return data;\n        },\n\n        transformTimeToTimestamp(_series) {\n            let date;\n\n            if (_series) {\n                for (let i = 0, len1 = _series.length; i < len1; i++) {\n                    date = new Date(_series[i].time);\n                    _series[i].time = Math.floor(date.getTime() / 1000);\n                }\n            }\n        },\n\n        injectMissingValues(_series, _options) {\n            let data = [];\n            let prevItem;\n            let item;\n            let diff = 0;\n            const { timeResolution } = _options;\n            const { value } = _options;\n            const useLastValue = value === 'last';\n\n            if (_series && timeResolution > 0) {\n                for (let i = 0, len1 = _series.length; i < len1; i++) {\n                    item = _series[i];\n\n                    if (i > 0) {\n                        prevItem = _series[i - 1];\n                        diff = item.time - prevItem.time;\n                        if (diff > timeResolution) {\n                            for (let j = 1, len2 = parseInt(diff / timeResolution); j < len2; j++) {\n                                data.push({\n                                    time: prevItem.time + j * timeResolution,\n                                    value: useLastValue ? prevItem.value : value,\n                                });\n                            }\n                        }\n                    }\n\n                    data.push({ ...item });\n                }\n            }\n\n            return data;\n        },\n\n        updateColors() {\n            const chartCP = this.getChartCustomProperties();\n            const series = this._series;\n            const { cSeries } = this;\n            const { chartOptions } = this;\n            const options = {\n                grid: {},\n                layout: {},\n                timeScale: {},\n                priceScale: {},\n            };\n            const grid = { ...chartOptions.grid };\n            const layout = { ...chartOptions.layout };\n            const timeScale = { ...chartOptions.timeScale };\n            const priceScale = { ...chartOptions.priceScale };\n\n            if (chartCP.vertLinesColor && (!grid.vertLines || !grid.vertLines.color)) {\n                options.grid.vertLines = { ...grid.vertLines, color: chartCP.vertLinesColor };\n            }\n\n            if (chartCP.horzLinesColor && (!grid.horzLines || !grid.horzLines.color)) {\n                options.grid.horzLines = { ...grid.horzLines, color: chartCP.horzLinesColor };\n            }\n\n            ['backgroundColor', 'textColor', 'fontSize', 'fontFamily'].forEach((_prop) => {\n                if (chartCP[_prop] && !layout[_prop]) {\n                    options.layout[_prop] = _prop === 'fontSize' ? parseInt(chartCP[_prop]) : chartCP[_prop];\n                }\n            });\n\n            if (chartCP.timeScaleBorderColor && !timeScale.borderColor) {\n                options.timeScale.borderColor = chartCP.timeScaleBorderColor;\n            }\n\n            if (chartCP.priceScaleBorderColor && !priceScale.borderColor) {\n                options.priceScale.borderColor = chartCP.priceScaleBorderColor;\n            }\n\n            this._chart.applyOptions(options);\n\n            Object.keys(series).forEach((_seriesKey) => {\n                const item = cSeries[_seriesKey];\n                const seriesOptions = { ...item.seriesOptions };\n\n                if (!item) {\n                    return;\n                }\n\n                if (chartCP.lineColor && (!seriesOptions || !seriesOptions.color)) {\n                    series[_seriesKey].applyOptions({\n                        color: chartCP.lineColor,\n                        lineColor: chartCP.lineColor,\n                        topColor: chartCP.topColor,\n                        bottomColor: chartCP.bottomColor,\n                        lineWidth: chartCP.lineWidth,\n                    });\n                }\n            });\n        },\n\n        getChartCustomProperties() {\n            const style = getComputedStyle(this.$el);\n            const cp = {\n                lineColor: style.getPropertyValue('--f-lightweight-chart-chart-line-color'),\n                textColor: style.getPropertyValue('--f-lightweight-chart-chart-text-color'),\n                topColor: style.getPropertyValue('--f-lightweight-chart-chart-top-color'),\n                bottomColor: style.getPropertyValue('--f-lightweight-chart-chart-bottom-color'),\n                lineWidth: style.getPropertyValue('--f-lightweight-chart-chart-line-width'),\n                vertLinesColor: style.getPropertyValue('--f-lightweight-chart-chart-vert-lines-color'),\n                horzLinesColor: style.getPropertyValue('--f-lightweight-chart-chart-horz-lines-color'),\n                backgroundColor: style.getPropertyValue('--f-lightweight-chart-chart-background-color'),\n                fontSize: style.getPropertyValue('--f-lightweight-chart-chart-font-size'),\n                fontFamily: style.getPropertyValue('--f-lightweight-chart-chart-font-family'),\n                timeScaleBorderColor: style.getPropertyValue('--f-lightweight-chart-chart-time-scale-border-color'),\n                priceScaleBorderColor: style.getPropertyValue('--f-lightweight-chart-chart-price-scale-border-color'),\n            };\n\n            Object.keys(cp).forEach((_key) => {\n                const color = cp[_key];\n\n                if (color) {\n                    cp[_key] = color.trim();\n                } else {\n                    delete cp[_key];\n                }\n            });\n\n            return cp;\n        },\n\n        destroyChart() {\n            if (this._chart) {\n                this._series = {};\n                this._chart.remove();\n                this._chart = null;\n            }\n        },\n\n        onWindowResize() {\n            const chart = this._chart;\n\n            if (chart) {\n                chart.resize(this.$refs.chartContainer.clientWidth, this.height);\n            }\n        },\n    },\n};\n</script>\n\n<style lang=\"scss\">\n@import 'style';\n</style>\n"]}]}